COMPLETE REPOSITORY STRUCTURE + CODE FROM: inventory-manager/src
======================================================================
Target folder for code: inventory-manager/src
======================================================================

FULL REPOSITORY STRUCTURE:
----------------------------------------
└── /
    ├── .streamlit/
    │   └── config.toml
    ├── barcodes/
    ├── data/
    │   ├── db.zip
    │   ├── records (2).db
    │   └── records.db
    ├── images/
    ├── inventory-manager/
    │   ├── 🎯 src/ [TARGET]
    │   │   ├── EbayDraftFiles/
    │   │   │   ├── ebay_drafts oct 16 21_21.csv
    │   │   │   └── ebay_drafts oct 16_21.21 (2).csv
    │   │   ├── gallery/
    │   │   │   ├── ⭐ __init__.py 🐍
    │   │   │   └── ⭐ generator.py 🐍
    │   │   ├── handlers/
    │   │   │   ├── ⭐ __init__.py 🐍
    │   │   │   ├── ⭐ barcode_generator.py 🐍
    │   │   │   ├── ⭐ discogs_handler.py 🐍
    │   │   │   ├── ⭐ draft_csv_handler.py 🐍
    │   │   │   ├── ⭐ ebay_handler.py 🐍
    │   │   │   ├── ⭐ genre_handler.py 🐍
    │   │   │   ├── ⭐ imagebb_handler.py 🐍
    │   │   │   └── ⭐ price_handler.py 🐍
    │   │   ├── tabs/
    │   │   │   ├── ⭐ check_in_tab.py 🐍
    │   │   │   ├── ⭐ checkout_tab.py 🐍
    │   │   │   ├── ⭐ database_switch_tab.py 🐍
    │   │   │   ├── ⭐ debug_tab.py 🐍
    │   │   │   ├── ⭐ expenses_tab.py 🐍
    │   │   │   ├── ⭐ genre_mappings_tab.py 🐍
    │   │   │   ├── ⭐ import_export_tab.py 🐍
    │   │   │   ├── ⭐ records_tab.py 🐍
    │   │   │   └── ⭐ statistics_tab.py 🐍
    │   │   ├── ⭐ config.py 🐍
    │   │   ├── ⭐ database_manager.py 🐍
    │   │   ├── ⭐ ebay_csv_merger.py 🐍
    │   │   ├── ⭐ image_formatter.py 🐍
    │   │   ├── print_config.json
    │   │   ├── records.zip
    │   │   ├── Screenshot from 2025-10-24 21-15-56.png
    │   │   ├── ⭐ sku_generator.py 🐍
    │   │   └── ⭐ streamlit_app.py 🐍
    │   ├── current_database.txt
    │   ├── print_config.json
    │   └── requirements.txt
    ├── payloads/
    ├── scripts/
    │   └── export_gallery_data.py 🐍
    ├── web/
    │   └── public/
    │       ├── assets/
    │       ├── css/
    │       │   └── style.css
    │       ├── fonts/
    │       │   ├── forum-regular-webfont.eot
    │       │   ├── forum-regular-webfont.svg
    │       │   ├── forum-regular-webfont.ttf
    │       │   └── forum-regular-webfont.woff
    │       ├── images/
    │       │   ├── art-in-record-store.png
    │       │   ├── audio-gear.jpg
    │       │   ├── background.png
    │       │   ├── bg-body.jpg
    │       │   ├── bg-header.png
    │       │   ├── border-horizontal.gif
    │       │   ├── button-plus.png
    │       │   ├── cassette-tapes.png
    │       │   ├── frame1.gif
    │       │   ├── frame2.gif
    │       │   ├── icons.png
    │       │   ├── interface.png
    │       │   ├── logo.png
    │       │   ├── pig_head.png
    │       │   ├── pigstyle_page.png
    │       │   ├── pigstyle_records.png
    │       │   ├── pigstyle_text.png
    │       │   ├── recliner.png
    │       │   ├── record-store-exterior.jpg
    │       │   ├── records_text.png
    │       │   ├── shadow.png
    │       │   ├── vinyl_records.jpg
    │       │   └── yellow-record.png
    │       ├── js/
    │       │   ├── gallery-popup.js
    │       │   └── script.js
    │       ├── catalog.html
    │       ├── CNAME
    │       ├── gallery-data.json
    │       ├── gallery-popup.html
    │       ├── index.html
    │       └── style.css
    ├── app.py 🐍
    ├── current_database.txt
    ├── print_config.json
    ├── README.md
    ├── repo_structure.py 🐍
    ├── REPO_STRUCTURE_AND_CODE.txt
    └── requirements.txt

======================================================================

PYTHON CODE FROM: inventory-manager/src
======================================================================

FILE: inventory-manager/src/streamlit_app.py
--------------------------------------------------
import sys
import os

# Add the correct path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'apps/inventory-manager/src'))

# Now import all modules
import streamlit as st
from pathlib import Path
import glob
from dotenv import load_dotenv
from database_manager import DatabaseManager
from handlers.discogs_handler import DiscogsHandler
from tabs.records_tab import RecordsTab
from tabs.check_in_tab import CheckInTab
from tabs.statistics_tab import StatisticsTab
from tabs.debug_tab import DebugTab
from tabs.database_switch_tab import DatabaseSwitchTab
from tabs.checkout_tab import CheckoutTab
from tabs.expenses_tab import ExpensesTab
from handlers.ebay_handler import EbayHandler

# --- Load environment variables ---
try:
    load_dotenv()
except:
    pass

# --- Configuration ---
IMAGE_FOLDER = Path("images")
IMAGE_FOLDER.mkdir(parents=True, exist_ok=True)
PAYLOADS_FOLDER = Path("payloads")
PAYLOADS_FOLDER.mkdir(parents=True, exist_ok=True)

# Database persistence file
DB_PERSISTENCE_FILE = "current_database.txt"

def get_environment_variables(debug_tab):
    """Get environment variables from either .env file or Streamlit secrets"""
    env_vars = {}
    
    required_vars = [
        "IMAGEBB_API_KEY",
        "DISCOGS_USER_TOKEN", 
        "EBAY_CLIENT_ID",
        "EBAY_CLIENT_SECRET"
    ]
    
    # Only log environment variable status once per session
    if 'env_vars_loaded' not in st.session_state:
        st.session_state.env_vars_loaded = False
    
    for var in required_vars:
        try:
            if hasattr(st, 'secrets') and var in st.secrets:
                env_vars[var] = st.secrets[var]
                if not st.session_state.env_vars_loaded:
                    debug_tab.add_log("SECRETS", f"✅ {var} loaded from secrets", {"source": "secrets"})
            else:
                env_value = os.getenv(var)
                if env_value:
                    env_vars[var] = env_value
                    if not st.session_state.env_vars_loaded:
                        debug_tab.add_log("ENV", f"✅ {var} loaded from environment", {"source": ".env"})
                else:
                    env_vars[var] = None
                    if not st.session_state.env_vars_loaded:
                        debug_tab.add_log("ERROR", f"❌ {var} not found in secrets or environment")
        except Exception as e:
            env_vars[var] = None
            if not st.session_state.env_vars_loaded:
                debug_tab.add_log("ERROR", f"❌ Error loading {var}: {e}")
    
    # Mark environment variables as loaded for this session
    st.session_state.env_vars_loaded = True
    return env_vars

def get_persisted_database_path():
    """Get the persisted database path from file"""
    try:
        if os.path.exists(DB_PERSISTENCE_FILE):
            with open(DB_PERSISTENCE_FILE, 'r') as f:
                db_path = f.read().strip()
                if db_path and os.path.exists(db_path):
                    return db_path
    except Exception as e:
        st.error(f"Error reading persisted database path: {e}")
    return None

def persist_database_path(db_path):
    """Persist the database path to file"""
    try:
        with open(DB_PERSISTENCE_FILE, 'w') as f:
            f.write(db_path)
        return True
    except Exception as e:
        st.error(f"Error persisting database path: {e}")
        return False

def initialize_database_manager():
    """Initialize database manager with persisted path or default"""
    persisted_path = get_persisted_database_path()
    if persisted_path:
        return DatabaseManager(persisted_path)
    
    # Default database
    return DatabaseManager()

def main():
    """Main function to run the Streamlit app"""
    # Set page config - this must be the first Streamlit command
    st.set_page_config(
        page_title="PigStyle Inventory Manager",
        page_icon="🎵",
        layout="wide"
    )
    
    # Initialize debug tab FIRST and use the SAME instance everywhere
    debug_tab = DebugTab()
    
    # Get environment variables
    env_vars = get_environment_variables(debug_tab)

    IMAGEBB_API_KEY = env_vars["IMAGEBB_API_KEY"]
    DISCOGS_USER_TOKEN = env_vars["DISCOGS_USER_TOKEN"]
    EBAY_CLIENT_ID = env_vars["EBAY_CLIENT_ID"]
    EBAY_CLIENT_SECRET = env_vars["EBAY_CLIENT_SECRET"]

    # Initialize session state defaults
    if "db_manager" not in st.session_state:
        st.session_state.db_manager = initialize_database_manager()
        debug_tab.add_log("DATABASE", f"Database manager initialized with: {st.session_state.db_manager.db_path}")

    if "search_results" not in st.session_state:
        st.session_state.search_results = {}

    if "current_search" not in st.session_state:
        st.session_state.current_search = ""

    if "last_added" not in st.session_state:
        st.session_state.last_added = None

    if "records_updated" not in st.session_state:
        st.session_state.records_updated = 0

    if "selected_records" not in st.session_state:
        st.session_state.selected_records = []

    # Initialize Discogs handler
    discogs_handler = None
    if DISCOGS_USER_TOKEN:
        try:
            discogs_handler = DiscogsHandler(DISCOGS_USER_TOKEN, debug_tab)
        except Exception as e:
            debug_tab.add_log("ERROR", f"Failed to initialize Discogs: {e}")
            discogs_handler = None
    
    # Initialize eBay handler
    ebay_handler = None
    if EBAY_CLIENT_ID and EBAY_CLIENT_SECRET:
        try:
            ebay_handler = EbayHandler(EBAY_CLIENT_ID, EBAY_CLIENT_SECRET, debug_tab)
        except Exception as e:
            debug_tab.add_log("ERROR", f"Failed to initialize eBay: {e}")
            ebay_handler = None
 
    # Initialize all tabs - pass the SAME debug_tab instance to all
    records_tab = RecordsTab(discogs_handler, debug_tab, ebay_handler)
    check_in_tab = CheckInTab(discogs_handler, debug_tab, ebay_handler, records_tab.price_handler)
    statistics_tab = StatisticsTab()
    database_switch_tab = DatabaseSwitchTab()
    checkout_tab = CheckoutTab()
    expenses_tab = ExpensesTab()
    # Use the SAME debug_tab instance for rendering

    # Create tabs with new order
    tabs = st.tabs([
        "🗃️ Database",
        "📥 Check In", 
        "📦 Inventory",
        "📦 Checkout",
        "💰 Income",
        "💰 Expenses",
        "📊 Statistics",
        "🔧 Debug"
    ])
    
    with tabs[0]:
        database_switch_tab.render()
    
    with tabs[1]:
        check_in_tab.render()
    
    with tabs[2]:
        records_tab.render_inventory_tab()
    
    with tabs[3]:
        checkout_tab.render()
    
    with tabs[4]:
        records_tab.render_sold_tab()
    
    with tabs[5]:
        expenses_tab.render()
        
    with tabs[6]:
        statistics_tab.render()
        
    with tabs[7]:
        debug_tab.render()  # Use the SAME instance


if __name__ == "__main__":
    main()

======================================================================

FILE: inventory-manager/src/sku_generator.py
--------------------------------------------------
# sku_generator.py
class SKUGenerator:
    def __init__(self, max_length=30):
        self.max_length = max_length

    def generate(self, title, category):
        """
        Generate SKU from title and category.

        If title is in format [a] - [b], SKU becomes truncated a + truncated b + truncated category.
        Max total length = self.max_length, no padding.
        """
        title = title.strip()
        category = category.strip().upper().replace(" ", "")
        a, b = "", ""

        if " - " in title:
            parts = title.split(" - ", 1)
            a, b = parts[0].upper().replace(" ", ""), parts[1].upper().replace(" ", "")
        else:
            # Fallback: use full title
            a, b = title.upper().replace(" ", ""), ""

        # Allocate characters proportionally
        # Leave room for two hyphens
        remaining = self.max_length - 2
        if a and b:
            max_len_a = remaining // 2
            max_len_b = remaining - max_len_a
            a_trunc = a[:max_len_a]
            b_trunc = b[:max_len_b]
        else:
            # Only one part
            a_trunc = a[:remaining]
            b_trunc = ""

        # Truncate category if needed
        cat_len = self.max_length - len(a_trunc) - len(b_trunc) - (1 if b_trunc else 0)
        cat_trunc = category[:cat_len]

        if b_trunc:
            sku = f"{a_trunc}-{b_trunc}-{cat_trunc}"
        else:
            sku = f"{a_trunc}-{cat_trunc}"

        return sku


======================================================================

FILE: inventory-manager/src/database_manager.py
--------------------------------------------------
import sqlite3
import pandas as pd
import os
from datetime import datetime

class DatabaseManager:
    """Handles all database operations for Discogs data"""
    
    def __init__(self, db_path=None):
        self.db_path = db_path or os.getenv('DATABASE_PATH', 'discogs_data.db')
        self._init_database()
    
    def _init_database(self):
        """Initialize SQLite database with required tables"""
        conn = self._get_connection()
        cursor = conn.cursor()
        
        # Records table - using the actual column names from your schema
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS records (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                artist TEXT NOT NULL,
                title TEXT NOT NULL,
                discogs_median_price REAL,
                discogs_lowest_price REAL,
                discogs_highest_price REAL,
                ebay_median_price REAL,
                ebay_lowest_price REAL,
                ebay_highest_price REAL,
                price REAL,
                discogs_have INTEGER DEFAULT 0,
                discogs_want INTEGER DEFAULT 0,
                genre TEXT,
                image_url TEXT,
                year TEXT,
                barcode TEXT,
                catalog_number TEXT,
                format TEXT,
                condition TEXT,
                store_price REAL,
                file_at TEXT,
                status TEXT DEFAULT 'inventory',
                price_tag_printed BOOLEAN DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Add price column if it doesn't exist (for existing databases)
        try:
            cursor.execute("ALTER TABLE records ADD COLUMN price REAL")
        except sqlite3.OperationalError:
            # Column already exists, ignore error
            pass
        
        # Add status column if it doesn't exist (for existing databases)
        try:
            cursor.execute("ALTER TABLE records ADD COLUMN status TEXT DEFAULT 'inventory'")
        except sqlite3.OperationalError:
            # Column already exists, ignore error
            pass
        
        # Add price_tag_printed column if it doesn't exist
        try:
            cursor.execute("ALTER TABLE records ADD COLUMN price_tag_printed BOOLEAN DEFAULT 0")
        except sqlite3.OperationalError:
            # Column already exists, ignore error
            pass
        
        # Add updated_at column if it doesn't exist
        try:
            cursor.execute("ALTER TABLE records ADD COLUMN updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
        except sqlite3.OperationalError:
            # Column already exists, ignore error
            pass
        
        # Failed searches table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS failed_searches (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                search_term TEXT NOT NULL,
                error_details TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Genre domain table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS genres (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                genre_name TEXT UNIQUE NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # Genre by artist cross-reference table - with UNIQUE constraint on artist_name
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS genre_by_artist (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                artist_name TEXT UNIQUE NOT NULL,
                genre_id INTEGER NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (genre_id) REFERENCES genres (id)
            )
        ''')
        
        # Expenses table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS expenses (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                description TEXT NOT NULL,
                amount REAL NOT NULL,
                receipt_image BLOB,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def _get_connection(self):
        """Get database connection"""
        return sqlite3.connect(self.db_path)
    
    def save_record(self, result_data):
        """Save record to database using correct column names"""
        conn = self._get_connection()
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO records 
            (artist, title, discogs_median_price, discogs_lowest_price, discogs_highest_price,
             ebay_median_price, ebay_lowest_price, ebay_highest_price, price,
             genre, image_url, catalog_number, format, barcode, condition, year, discogs_have, discogs_want, file_at, status, price_tag_printed)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            result_data.get('artist', result_data.get('discogs_artist', '')),
            result_data.get('title', result_data.get('discogs_title', '')),
            result_data.get('discogs_median_price'),
            result_data.get('discogs_lowest_price'),
            result_data.get('discogs_highest_price'),
            result_data.get('ebay_median_price'),
            result_data.get('ebay_lowest_price'),
            result_data.get('ebay_highest_price'),
            result_data.get('price'),
            result_data.get('genre', ''),
            result_data.get('image_url', ''),
            result_data.get('catalog_number', ''),
            result_data.get('format', ''),
            result_data.get('barcode', ''),
            result_data.get('condition', ''),
            result_data.get('year', ''),
            result_data.get('discogs_have', 0),
            result_data.get('discogs_want', 0),
            result_data.get('file_at', ''),
            result_data.get('status', 'inventory'),
            0  # price_tag_printed starts as False
        ))
        
        conn.commit()
        conn.close()
        return cursor.lastrowid
    
    def update_record(self, record_id, updates):
        """Update a record and mark price tag as dirty if price-related fields change"""
        conn = self._get_connection()
        cursor = conn.cursor()
        
        # Check if any price-related fields are being updated
        price_related_fields = ['artist', 'title', 'genre', 'barcode', 'discogs_median_price', 
                               'ebay_median_price', 'price', 'file_at']
        
        # Get current values
        cursor.execute('SELECT artist, title, genre, barcode, discogs_median_price, ebay_median_price, price, file_at FROM records WHERE id = ?', (record_id,))
        current_values = cursor.fetchone()
        
        # Check if any price-related fields are changing
        price_tag_dirty = False
        if current_values:
            current_dict = {
                'artist': current_values[0],
                'title': current_values[1],
                'genre': current_values[2],
                'barcode': current_values[3],
                'discogs_median_price': current_values[4],
                'ebay_median_price': current_values[5],
                'price': current_values[6],
                'file_at': current_values[7]
            }
            
            for field in price_related_fields:
                if field in updates and updates[field] != current_dict[field]:
                    price_tag_dirty = True
                    break
        
        # Build update query
        set_clause = []
        values = []
        for field, value in updates.items():
            set_clause.append(f"{field} = ?")
            values.append(value)
        
        # Add updated_at timestamp
        set_clause.append("updated_at = CURRENT_TIMESTAMP")
        
        # If price-related fields changed, mark price tag as not printed
        if price_tag_dirty:
            set_clause.append("price_tag_printed = 0")
        
        values.append(record_id)
        
        query = f"UPDATE records SET {', '.join(set_clause)} WHERE id = ?"
        cursor.execute(query, values)
        
        conn.commit()
        conn.close()
        return True
    
    def mark_price_tags_printed(self, record_ids):
        """Mark price tags as printed for given record IDs"""
        conn = self._get_connection()
        cursor = conn.cursor()
        
        placeholders = ','.join(['?'] * len(record_ids))
        cursor.execute(f'UPDATE records SET price_tag_printed = 1 WHERE id IN ({placeholders})', record_ids)
        
        conn.commit()
        conn.close()
        return True
    
    def save_expense(self, description, amount, receipt_image=None):
        """Save expense to database"""
        conn = self._get_connection()
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO expenses (description, amount, receipt_image)
            VALUES (?, ?, ?)
        ''', (description, amount, receipt_image))
        
        conn.commit()
        expense_id = cursor.lastrowid
        conn.close()
        return expense_id
    
    def get_all_expenses(self):
        """Get all expenses from database"""
        conn = self._get_connection()
        df = pd.read_sql('SELECT * FROM expenses ORDER BY created_at DESC', conn)
        conn.close()
        return df
    
    def save_failed_search(self, search_term, error_details):
        """Save failed search to database"""
        conn = self._get_connection()
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO failed_searches (search_term, error_details)
            VALUES (?, ?)
        ''', (search_term, error_details))
        
        conn.commit()
        conn.close()
        return cursor.lastrowid
    
    def get_all_records(self):
        """Get all records from database"""
        conn = self._get_connection()
        df = pd.read_sql('SELECT * FROM records ORDER BY created_at DESC', conn)
        conn.close()
        return df
    
    def get_all_failed_searches(self):
        """Get all failed searches from database"""
        conn = self._get_connection()
        df = pd.read_sql('SELECT * FROM failed_searches ORDER BY created_at DESC', conn)
        conn.close()
        return df
    
    def get_recent_records(self, limit=100):
        """Get recent records"""
        conn = self._get_connection()
        df = pd.read_sql(f'SELECT * FROM records ORDER BY created_at DESC LIMIT {limit}', conn)
        conn.close()
        return df
    
    def get_recent_failed_searches(self, limit=100):
        """Get recent failed searches"""
        conn = self._get_connection()
        df = pd.read_sql(f'SELECT * FROM failed_searches ORDER BY created_at DESC LIMIT {limit}', conn)
        conn.close()
        return df
    
    def get_database_stats(self):
        """Get database statistics"""
        conn = self._get_connection()
        
        # Use COALESCE to handle NULL values and ensure we get 0 instead of None
        records_count = pd.read_sql('SELECT COALESCE(COUNT(*), 0) as count FROM records', conn).iloc[0]['count']
        failed_count = pd.read_sql('SELECT COALESCE(COUNT(*), 0) as count FROM failed_searches', conn).iloc[0]['count']
        
        # For latest timestamps, handle case where tables are empty
        latest_record_df = pd.read_sql('SELECT MAX(created_at) as latest FROM records', conn)
        latest_record = latest_record_df.iloc[0]['latest'] if not latest_record_df.empty and latest_record_df.iloc[0]['latest'] is not None else "None"
        
        latest_failed_df = pd.read_sql('SELECT MAX(created_at) as latest FROM failed_searches', conn)
        latest_failed = latest_failed_df.iloc[0]['latest'] if not latest_failed_df.empty and latest_failed_df.iloc[0]['latest'] is not None else "None"
        
        conn.close()
        
        return {
            'records_count': int(records_count),  # Ensure it's an integer
            'failed_count': int(failed_count),    # Ensure it's an integer
            'latest_record': latest_record,
            'latest_failed': latest_failed,
            'db_path': self.db_path
        }
    
    # Genre management methods
    def get_all_genres(self):
        """Get all available genres"""
        conn = self._get_connection()
        df = pd.read_sql('SELECT * FROM genres ORDER BY genre_name', conn)
        conn.close()
        return df
    
    def get_artists_with_genres(self):
        """Get all artists with their assigned genres"""
        conn = self._get_connection()
        df = pd.read_sql('''
            SELECT 
                gba.artist_name,
                g.genre_name,
                gba.genre_id,
                gba.id as mapping_id
            FROM genre_by_artist gba
            JOIN genres g ON gba.genre_id = g.id
            ORDER BY gba.artist_name
        ''', conn)
        conn.close()
        return df
    
    def get_all_artists_with_genres(self, search_term=None):
        """Get all artists from records and their assigned genres (including unassigned)"""
        conn = self._get_connection()
        
        if search_term:
            query = '''
                SELECT DISTINCT 
                    r.artist as artist_name,
                    g.genre_name
                FROM records r
                LEFT JOIN genre_by_artist gba ON r.artist = gba.artist_name
                LEFT JOIN genres g ON gba.genre_id = g.id
                WHERE r.artist LIKE ?
                ORDER BY r.artist
            '''
            df = pd.read_sql(query, conn, params=(f'%{search_term}%',))
        else:
            query = '''
                SELECT DISTINCT 
                    r.artist as artist_name,
                    g.genre_name
                FROM records r
                LEFT JOIN genre_by_artist gba ON r.artist = gba.artist_name
                LEFT JOIN genres g ON gba.genre_id = g.id
                ORDER BY r.artist
            '''
            df = pd.read_sql(query, conn)
        
        conn.close()
        return df
    
    def search_artists_with_genres(self, search_term):
        """Search artists with genres by artist name"""
        conn = self._get_connection()
        df = pd.read_sql('''
            SELECT 
                gba.artist_name,
                g.genre_name,
                gba.genre_id,
                gba.id as mapping_id
            FROM genre_by_artist gba
            JOIN genres g ON gba.genre_id = g.id
            WHERE gba.artist_name LIKE ?
            ORDER BY gba.artist_name
        ''', conn, params=(f'%{search_term}%',))
        conn.close()
        return df
    
    def get_artists_without_genres(self):
        """Get artists that don't have genres assigned yet"""
        conn = self._get_connection()
        df = pd.read_sql('''
            SELECT DISTINCT artist as artist_name
            FROM records 
            WHERE artist NOT IN (SELECT artist_name FROM genre_by_artist)
            ORDER BY artist
        ''', conn)
        conn.close()
        return df
    
    def add_genre(self, genre_name):
        """Add a new genre"""
        conn = self._get_connection()
        cursor = conn.cursor()
        
        try:
            cursor.execute('INSERT INTO genres (genre_name) VALUES (?)', (genre_name,))
            conn.commit()
            genre_id = cursor.lastrowid
            success = True
        except sqlite3.IntegrityError:
            # Genre already exists
            genre_id = None
            success = False
        finally:
            conn.close()
            
        return success, genre_id
    
    def delete_genre(self, genre_id):
        """Delete a genre and remove all artist associations"""
        conn = self._get_connection()
        cursor = conn.cursor()
        
        try:
            # First remove all artist associations
            cursor.execute('DELETE FROM genre_by_artist WHERE genre_id = ?', (genre_id,))
            # Then delete the genre
            cursor.execute('DELETE FROM genres WHERE id = ?', (genre_id,))
            conn.commit()
            success = True
        except Exception as e:
            success = False
        finally:
            conn.close()
            
        return success
    
    def assign_genre_to_artist(self, artist_name, genre_id):
        """Assign a genre to an artist"""
        conn = self._get_connection()
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
                INSERT OR REPLACE INTO genre_by_artist (artist_name, genre_id)
                VALUES (?, ?)
            ''', (artist_name, genre_id))
            conn.commit()
            success = True
        except Exception as e:
            success = False
        finally:
            conn.close()
            
        return success
    
    def remove_genre_from_artist(self, artist_name, genre_id):
        """Remove a genre assignment from an artist"""
        conn = self._get_connection()
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
                DELETE FROM genre_by_artist 
                WHERE artist_name = ? AND genre_id = ?
            ''', (artist_name, genre_id))
            conn.commit()
            success = True
        except Exception as e:
            success = False
        finally:
            conn.close()
            
        return success
    
    def remove_genre_from_artist_by_name(self, artist_name):
        """Remove all genre assignments from an artist by name"""
        conn = self._get_connection()
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
                DELETE FROM genre_by_artist 
                WHERE artist_name = ?
            ''', (artist_name,))
            conn.commit()
            success = True
        except Exception as e:
            success = False
        finally:
            conn.close()
            
        return success
    
    def get_artist_genre(self, artist_name):
        """Get the genre assigned to an artist"""
        conn = self._get_connection()
        df = pd.read_sql('''
            SELECT g.genre_name, g.id as genre_id
            FROM genre_by_artist gba
            JOIN genres g ON gba.genre_id = g.id
            WHERE gba.artist_name = ?
        ''', conn, params=(artist_name,))
        conn.close()
        return df.iloc[0] if len(df) > 0 else None
    
    def get_genre_statistics(self):
        """Get statistics about genres and records"""
        conn = self._get_connection()
        
        # First check if genre_by_artist table exists and has data
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='genre_by_artist'")
        genre_table_exists = cursor.fetchone() is not None
        
        if not genre_table_exists:
            # Return empty dataframe if genre tables don't exist
            df = pd.DataFrame(columns=['genre_name', 'record_count', 'artist_count'])
        else:
            # Use the correct query with proper column names
            df = pd.read_sql('''
                SELECT 
                    g.genre_name,
                    COUNT(r.id) as record_count,
                    COUNT(DISTINCT gba.artist_name) as artist_count
                FROM genres g
                LEFT JOIN genre_by_artist gba ON g.id = gba.genre_id
                LEFT JOIN records r ON gba.artist_name = r.artist
                GROUP BY g.id, g.genre_name
                ORDER BY record_count DESC
            ''', conn)
        
        conn.close()
        return df
    
    def clear_database(self):
        """Clear all data from database (use with caution!)"""
        conn = self._get_connection()
        cursor = conn.cursor()
        cursor.execute('DELETE FROM records')
        cursor.execute('DELETE FROM failed_searches')
        cursor.execute('DELETE FROM genre_by_artist')
        cursor.execute('DELETE FROM genres')
        cursor.execute('DELETE FROM expenses')
        conn.commit()
        conn.close()
    
    def search_records(self, search_term):
        """Search for records by search term"""
        conn = self._get_connection()
        df = pd.read_sql(
            'SELECT * FROM records WHERE artist LIKE ? OR title LIKE ? ORDER BY created_at DESC',
            conn,
            params=(f'%{search_term}%', f'%{search_term}%')
        )
        conn.close()
        return df
    
    def get_record_by_barcode(self, barcode):
        """Get a record by barcode"""
        conn = self._get_connection()
        df = pd.read_sql(
            'SELECT * FROM records WHERE barcode = ?',
            conn,
            params=(barcode,)
        )
        conn.close()
        return df.iloc[0] if len(df) > 0 else None
    
    def update_file_at_for_all_records(self):
        """Update file_at column for all records with genre(file_at) format"""
        conn = self._get_connection()
        cursor = conn.cursor()
        
        # Get all records
        cursor.execute('SELECT id, artist, genre FROM records')
        records = cursor.fetchall()
        
        updated_count = 0
        for record in records:
            record_id = record[0]
            artist = record[1]
            genre = record[2] or 'Unknown'
            file_at_letter = self._calculate_file_at(artist)
            file_at_value = f"{genre}({file_at_letter})"
            
            cursor.execute('UPDATE records SET file_at = ? WHERE id = ?', (file_at_value, record_id))
            updated_count += 1
        
        conn.commit()
        conn.close()
        return updated_count
    
    def _calculate_file_at(self, artist):
        """Calculate file_at value for an artist"""
        if not artist:
            return "?"
        
        # Remove leading/trailing whitespace and convert to lowercase for processing
        artist_clean = artist.strip().lower()
        
        # Handle "The " prefix
        if artist_clean.startswith('the '):
            artist_clean = artist_clean[4:]
        
        # Handle numbers
        if artist_clean and artist_clean[0].isdigit():
            number_words = {
                '0': 'zero', '1': 'one', '2': 'two', '3': 'three', '4': 'four',
                '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine'
            }
            first_char = artist_clean[0]
            return number_words.get(first_char, '?')[0].upper()
        
        # Return first character if it's a letter
        if artist_clean and artist_clean[0].isalpha():
            return artist_clean[0].upper()
        
        return "?"

======================================================================

FILE: inventory-manager/src/config.py
--------------------------------------------------
import os
import json
from pathlib import Path

class PrintConfig:
    def __init__(self, config_file="print_config.json"):
        self.config_file = config_file
        self.defaults = {
            "label_width_mm": 45.0,
            "label_height_mm": 16.80,
            "left_margin_mm": 6.50,
            "gutter_spacing_mm": 6.50,
            "top_margin_mm": 14.00,
            "font_size": 7,
            "last_genre": "",
            "genre_font_size": 48
        }
        self.config = self._load_config()
    
    def _load_config(self):
        """Load configuration from file or use defaults"""
        if os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r') as f:
                    loaded_config = json.load(f)
                    # Merge with defaults to ensure all keys exist
                    config = self.defaults.copy()
                    config.update(loaded_config)
                    return config
            except Exception as e:
                print(f"Error loading config file: {e}. Using defaults.")
                return self.defaults.copy()
        else:
            # Create default config file
            self._save_config(self.defaults)
            return self.defaults.copy()
    
    def _save_config(self, config):
        """Save configuration to file"""
        try:
            with open(self.config_file, 'w') as f:
                json.dump(config, f, indent=2)
        except Exception as e:
            print(f"Error saving config file: {e}")
    
    def get(self, key, default=None):
        """Get a configuration value with optional default"""
        return self.config.get(key, default if default is not None else self.defaults.get(key))
    
    def update(self, new_config):
        """Update configuration and save to file"""
        self.config.update(new_config)
        self._save_config(self.config)
    
    def get_all(self):
        """Get all configuration values"""
        return self.config.copy()

======================================================================

FILE: inventory-manager/src/ebay_csv_merger.py
--------------------------------------------------
import pandas as pd

# Load CSVs
revise = pd.read_csv("/home/arjan-ubuntu/Downloads/eBay-edit-price-quantity-template-2025-10-16-11260725431.csv", skiprows=1)
draft = pd.read_csv("/home/arjan-ubuntu/Downloads/merged_ebay.csv", skiprows=1)

# Standardize SKU column
revise.rename(columns={"Custom label (SKU)": "SKU"}, inplace=True)
draft.rename(columns={"Custom label (SKU)": "SKU"}, inplace=True)

# Merge draft and revise on SKU, preferring draft data
merged = pd.merge(draft, revise[['SKU', 'Start price', 'Available quantity']], 
                  on='SKU', how='outer', suffixes=('_draft', '_revise'))

# Update Price and Quantity: prefer revise if present
merged['Price'] = merged['Start price'].combine_first(merged['Price'])
merged['Quantity'] = merged['Available quantity'].combine_first(merged['Quantity'])

# Drop temporary columns
merged.drop(columns=['Start price', 'Available quantity'], inplace=True)

# Remove exact duplicates (keeping the first occurrence)
merged = merged.drop_duplicates(subset=['SKU'])

# Save final CSV
merged.to_csv("merged_ebay.csv", index=False)


======================================================================

FILE: inventory-manager/src/image_formatter.py
--------------------------------------------------
from PIL import Image
import io

class ImageFormatter:
    """
    Handles resizing and compressing images for eBay upload
    to reduce memory usage while keeping quality usable.
    """
    def __init__(self, max_width=800, max_height=800, quality=85):
        self.max_width = max_width
        self.max_height = max_height
        self.quality = quality

    def format_image(self, image_path, save_path=None):
        """
        Resizes and compresses the image at image_path.
        If save_path is provided, saves the formatted image to that path.
        Returns a BytesIO buffer if save_path is None.
        """
        img = Image.open(image_path)
        img = img.convert("RGB")  # Ensure consistent format

        # Resize maintaining aspect ratio
        img.thumbnail((self.max_width, self.max_height))

        # Save to a BytesIO buffer to control compression
        buffer = io.BytesIO()
        img.save(buffer, format="JPEG", quality=self.quality, optimize=True)
        buffer.seek(0)

        if save_path:
            with open(save_path, "wb") as f:
                f.write(buffer.read())
            return save_path
        else:
            return buffer


======================================================================

FILE: inventory-manager/src/gallery/__init__.py
--------------------------------------------------


======================================================================

FILE: inventory-manager/src/gallery/generator.py
--------------------------------------------------


======================================================================

FILE: inventory-manager/src/tabs/database_switch_tab.py
--------------------------------------------------
import streamlit as st
import os
import glob
import tempfile
from pathlib import Path

class DatabaseSwitchTab:
    def __init__(self):
        pass
    
    def get_available_databases(self):
        """Get all .db files in current directory and subdirectories"""
        db_files = []
        
        # Check current directory and subdirectories
        patterns = ["*.db", "*/*.db", "*/*/*.db"]
        for pattern in patterns:
            db_files.extend(glob.glob(pattern))
        
        return db_files
    
    def persist_database_path(self, db_path):
        """Persist the database path to file"""
        try:
            with open("current_database.txt", 'w') as f:
                f.write(db_path)
            return True
        except Exception as e:
            st.error(f"Error persisting database path: {e}")
            return False
    
    def render(self):
        st.header("🗃️ Database Manager")
        
        # Current database info
        if hasattr(st.session_state, 'db_manager'):
            current_db = st.session_state.db_manager.db_path
            st.write(f"**Current Database:** `{current_db}`")
        
        # Database selection
        st.subheader("Select Existing Database")
        available_dbs = self.get_available_databases()
        
        if available_dbs:
            selected_db = st.selectbox(
                "Available databases:",
                available_dbs,
                index=available_dbs.index(current_db) if current_db in available_dbs else 0
            )
            
            if st.button("Switch to Selected Database", use_container_width=True):
                try:
                    st.session_state.db_manager = st.session_state.db_manager.__class__(selected_db)
                    if self.persist_database_path(selected_db):
                        st.success(f"✅ Switched to: {selected_db}")
                    st.rerun()
                except Exception as e:
                    st.error(f"Error switching database: {e}")
        else:
            st.info("No .db files found in current directory")
        
        # Create new database
        st.subheader("Create New")
        new_db_name = st.text_input("New database name:", value="new_inventory.db")
        if st.button("Create Database", use_container_width=True):
            try:
                if not new_db_name.endswith('.db'):
                    new_db_name += '.db'
                
                st.session_state.db_manager = st.session_state.db_manager.__class__(new_db_name)
                if self.persist_database_path(new_db_name):
                    st.success(f"✅ Created: {new_db_name}")
                st.rerun()
            except Exception as e:
                st.error(f"Error creating database: {e}")
        
        # Database operations
        st.subheader("📤 Upload Database")
        uploaded_file = st.file_uploader(
            "Upload .db file",
            type=['db'],
            help="Upload a SQLite database file"
        )
        
        if uploaded_file is not None:
            try:
                # Save uploaded file
                upload_path = uploaded_file.name
                with open(upload_path, 'wb') as f:
                    f.write(uploaded_file.getbuffer())
                
                st.session_state.db_manager = st.session_state.db_manager.__class__(upload_path)
                if self.persist_database_path(upload_path):
                    st.success(f"✅ Uploaded and loaded: {upload_path}")
                st.rerun()
            except Exception as e:
                st.error(f"Error uploading database: {e}")
        
        # Download current database
        st.subheader("📥 Download Database")
        if st.button("Download Current Database", use_container_width=True):
            try:
                if os.path.exists(current_db):
                    with open(current_db, 'rb') as f:
                        db_data = f.read()
                    
                    st.download_button(
                        label="⬇️ Download Database File",
                        data=db_data,
                        file_name=os.path.basename(current_db),
                        mime="application/octet-stream",
                        key="download_db"
                    )
                else:
                    st.error("Current database file not found")
            except Exception as e:
                st.error(f"Error downloading database: {e}")

======================================================================

FILE: inventory-manager/src/tabs/records_tab.py
--------------------------------------------------
import streamlit as st
import pandas as pd
from datetime import datetime
import os
import sqlite3
from typing import Dict, List, Optional, Tuple
from handlers.draft_csv_handler import DraftCSVHandler
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from reportlab.lib.units import mm
from reportlab.graphics.barcode import code128
import io
import json
import re
import time
from handlers.barcode_generator import BarcodeGenerator
from handlers.ebay_handler import EbayHandler
from handlers.price_handler import PriceHandler
from handlers.genre_handler import GenreHandler
from config import PrintConfig

class RecordsTab:
    def __init__(self, discogs_handler, debug_tab, ebay_handler=None):
        self.discogs_handler = discogs_handler
        self.ebay_handler = ebay_handler
        self.barcode_generator = BarcodeGenerator()
        self.debug_tab = debug_tab
        self.config = PrintConfig()
        self.price_handler = PriceHandler()
        self.genre_handler = GenreHandler()
        self._update_dimensions_from_config()
        
        # Initialize session state for eBay cutoff price
        if 'ebay_cutoff_price' not in st.session_state:
            st.session_state.ebay_cutoff_price = 3.99
        
        self.price_handler.set_ebay_cutoff_price(st.session_state.ebay_cutoff_price)
        
    def _update_dimensions_from_config(self):
        """Update dimensions from configuration"""
        config = self.config.get_all()
        self.label_width = config["label_width_mm"] * mm
        self.label_height = config["label_height_mm"] * mm
        self.left_margin = config["left_margin_mm"] * mm
        self.gutter_spacing = config["gutter_spacing_mm"] * mm
        self.top_margin = config["top_margin_mm"] * mm
        self.font_size = config["font_size"]
        self.page_width, self.page_height = letter

    def render_inventory_tab(self):
        """Render the inventory table functionality"""
        
        # Database statistics - direct count from inventory records
        stats = self._get_database_stats_direct('inventory')
            
        # Top row: Stats and action buttons - left aligned
        col1, col2, col3, col4, col5, col6, col7 = st.columns([1, 1, 1, 1, 1, 1, 1])
        with col1:
            st.metric("Inventory Records", stats['records_count'])
        with col2:
            if st.button("📦 Ebay List", use_container_width=True, help="Export selected records for eBay"):
                self._export_ebay_list()
        with col3:
            if st.button("🔢 Gen Barcodes", use_container_width=True, help="Generate missing barcodes"):
                self._generate_barcodes_for_existing_records()
        with col4:
            if st.button("📁 Gen File At", use_container_width=True, help="Regenerate file_at for selected records"):
                self._generate_file_at_for_selected_records()
        with col5:
            if st.button("🖨️ Print Selected", use_container_width=True, help="Print selected records"):
                self._generate_price_tags_pdf()
        with col6:
            if st.button("🗑️ Delete Selected", use_container_width=True, help="Delete selected records"):
                self._delete_selected_records()
        with col7:
            if st.button("🔄 Update eBay Prices", use_container_width=True, help="Update eBay prices for selected records"):
                self._update_ebay_prices_for_selected()
            
        # Price Settings and Genre Management in two columns
        col1, col2 = st.columns(2)
            
        with col1:
            # Price Settings
            st.subheader("Price Settings")
            new_cutoff = st.number_input(
                "eBay Cutoff Price",
                min_value=0.0,
                max_value=100.0,
                value=st.session_state.ebay_cutoff_price,
                step=0.5,
                help="Minimum price for eBay listings"
            )
            if new_cutoff != st.session_state.ebay_cutoff_price:
                st.session_state.ebay_cutoff_price = new_cutoff
                self.price_handler.set_ebay_cutoff_price(new_cutoff)
                st.success(f"eBay cutoff price updated to ${new_cutoff:.2f}")
                
            # Genre Management & Import/Export
            st.subheader("Genre Management & Import/Export")
            genre_col1, genre_col2 = st.columns(2)
                
            with genre_col1:
                if st.button("📤 Export Genre CSV", use_container_width=True, help="Export ID, Artist, Title, and Genre for all inventory records"):
                    self._export_genre_csv()
                
            with genre_col2:
                uploaded_file = st.file_uploader(
                    "Upload genre CSV to update genres",
                    type=['csv'],
                    help="Upload CSV with id and genre columns to update genres",
                    key="genre_import_uploader"
                )
                    
                if uploaded_file is not None:
                    try:
                        import_df = pd.read_csv(uploaded_file)
                            
                        if 'id' not in import_df.columns or 'genre' not in import_df.columns:
                            st.error("CSV must contain 'id' and 'genre' columns")
                        else:
                            if st.button("🔄 Update Genres", use_container_width=True):
                                updated_count = self._update_genres_from_csv(import_df)
                                if updated_count > 0:
                                    st.success(f"✅ Updated genres for {updated_count} records!")
                                    st.session_state.records_updated += 1
                                    st.rerun()
                                else:
                                    st.warning("No genres were updated.")
                            
                    except Exception as e:
                        st.error(f"Error processing import file: {e}")
            
            with col2:
                # Genre Signs Printing in its own box
                st.subheader("Genre Signs Printing")
                
                print_option = st.radio(
                    "Print option:",
                    ["Single Genre", "All Genres"],
                    key="print_option"
                )
                
                if print_option == "Single Genre":
                    genre_options = self.genre_handler.get_unique_genres()
                    genre_text = st.selectbox("Select genre:", options=genre_options, key="genre_select")
                else:
                    genre_text = "ALL_GENRES"
                
                font_size = st.slider("Font Size", min_value=24, max_value=96, value=48, key="genre_font_size")
                
                if st.button("🖨️ Generate Genre Sign PDF", use_container_width=True):
                    try:
                        if print_option == "All Genres":
                            genre_options = self.genre_handler.get_unique_genres()
                            pdf_buffer = self.genre_handler.generate_all_genre_signs_pdf(genre_options, font_size)
                            filename = f"all_genre_signs_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
                        else:
                            pdf_buffer = self.genre_handler.generate_genre_sign_pdf(genre_text, font_size)
                            filename = f"genre_sign_{genre_text.replace(' ', '_')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
                        
                        st.download_button(
                            label="⬇️ Download Genre Sign PDF",
                            data=pdf_buffer.getvalue(),
                            file_name=filename,
                            mime="application/pdf"
                        )
                    except Exception as e:
                        st.error(f"Error generating genre sign: {e}")
            
            # Second row: Search and filters
            col1, col2 = st.columns([2, 1])
            
            with col1:
                search_term = st.text_input(
                    "Search by artist, title, or barcode:",
                    key="search_inventory",
                    placeholder="Enter search term..."
                )
            
            with col2:
                # Quick filters
                filter_option = st.selectbox(
                    "Filter by",
                    options=["All Records", "No Barcode", "No Price Data", "No Genre", "No File At", "No eBay Price", "Price Tags Not Printed"],
                    key="quick_filter_inventory"
                )

            if stats['records_count'] > 0:
                self._render_records_table('inventory', search_term, filter_option)
            else:
                st.info("No records in inventory. Start by searching and adding records above!")
                
         

    def render_sold_tab(self):
        """Render the sold records table functionality - renamed to Income"""
        try:
            # Database statistics - direct count from sold records
            stats = self._get_database_stats_direct('sold')
            
            # Top row: Stats and action buttons
            col1, col2, col3 = st.columns([1, 1, 1])
            with col1:
                st.metric("Sold Records", stats['records_count'])
            with col2:
                if st.button("🔄 Return to Inventory", use_container_width=True, help="Return selected sold records to inventory"):
                    self._return_to_inventory()
            
            # Second row: Search and filters
            col1, col2 = st.columns([2, 1])
            
            with col1:
                search_term = st.text_input(
                    "Search by artist, title, or barcode:",
                    key="search_sold",
                    placeholder="Enter search term..."
                )
            
            with col2:
                # Quick filters
                filter_option = st.selectbox(
                    "Filter by",
                    options=["All Records", "No Barcode", "No Price Data", "No Genre", "No File At", "No eBay Price"],
                    key="quick_filter_sold"
                )

            if stats['records_count'] > 0:
                self._render_records_table('sold', search_term, filter_option)
            else:
                st.info("No sold records yet.")
                
        except Exception as e:
            st.error(f"Error loading sold records: {e}")

    def _export_genre_csv(self):
        """Export ID, Artist, Title, and Genre for all inventory records"""
        try:
            conn = st.session_state.db_manager._get_connection()
            df = pd.read_sql(
                "SELECT id, artist, title, genre FROM records WHERE status = 'inventory' ORDER BY artist, title",
                conn
            )
            conn.close()
            
            if len(df) > 0:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = f"genre_export_{timestamp}.csv"
                
                csv_data = df.to_csv(index=False)
                
                st.download_button(
                    label="⬇️ Download Genre CSV",
                    data=csv_data,
                    file_name=filename,
                    mime="text/csv",
                    key=f"download_genre_{timestamp}"
                )
                
                st.success(f"✅ Export ready! {len(df)} inventory records.")
            else:
                st.warning("No inventory records to export.")
                
        except Exception as e:
            st.error(f"Error exporting genre CSV: {e}")

    def _update_genres_from_csv(self, import_df):
        """Update genres from CSV data (only id and genre columns are used)"""
        try:
            updated_count = 0
            conn = st.session_state.db_manager._get_connection()
            cursor = conn.cursor()
            
            for _, row in import_df.iterrows():
                record_id = row.get('id')
                new_genre = row.get('genre')
                
                if record_id and pd.notna(new_genre):
                    # Use update_record to track changes properly
                    success = st.session_state.db_manager.update_record(record_id, {'genre': new_genre})
                    if success:
                        updated_count += 1
            
            conn.close()
            return updated_count
            
        except Exception as e:
            st.error(f"Error updating genres: {e}")
            return 0

    def _return_to_inventory(self):
        """Return selected sold records back to inventory"""
        if not st.session_state.selected_records:
            st.warning("Please select records first using the checkboxes in the table.")
            return
            
        try:
            selected_ids = st.session_state.selected_records
            if self._update_record_status(selected_ids, 'inventory'):
                st.success(f"✅ Returned {len(selected_ids)} records to inventory!")
                # Clear selection after operation
                st.session_state.selected_records = []
                st.session_state.records_updated += 1
                st.rerun()
        except Exception as e:
            st.error(f"Error returning records to inventory: {e}")

    def _update_record_status(self, record_ids, new_status):
        """Update status of records"""
        try:
            conn = st.session_state.db_manager._get_connection()
            cursor = conn.cursor()
            cursor.executemany('UPDATE records SET status = ? WHERE id = ?', [(new_status, id) for id in record_ids])
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            st.error(f"Error updating record status: {e}")
            return False

    def _update_ebay_prices_for_selected(self):
        """Update eBay prices for selected records"""
        if not st.session_state.selected_records:
            st.warning("Please select records first using the checkboxes in the table.")
            return
        
        if not self.ebay_handler:
            st.error("eBay handler not available. Check your eBay API credentials.")
            return
        
        try:
            selected_ids = st.session_state.selected_records
            placeholders = ','.join(['?'] * len(selected_ids))
            
            conn = st.session_state.db_manager._get_connection()
            df = pd.read_sql(f'SELECT * FROM records WHERE id IN ({placeholders})', conn, params=selected_ids)
            conn.close()
            
            updated_count = 0
            progress_bar = st.progress(0)
            status_text = st.empty()
            
            for i, (_, record) in enumerate(df.iterrows()):
                artist = record.get('artist', '')
                title = record.get('title', '')
                
                status_text.text(f"Updating {i+1}/{len(df)}: {artist} - {title}")
                
                try:
                    ebay_pricing = self.ebay_handler.get_ebay_pricing(artist, title)
                    if ebay_pricing:
                        # Use update_record to track changes properly
                        updates = {
                            'ebay_median_price': ebay_pricing.get('ebay_median_price'),
                            'ebay_lowest_price': ebay_pricing.get('ebay_lowest_price'),
                            'ebay_highest_price': ebay_pricing.get('ebay_highest_price')
                        }
                        success = st.session_state.db_manager.update_record(record['id'], updates)
                        if success:
                            updated_count += 1
                    
                except Exception as e:
                    pass
                
                progress_bar.progress((i + 1) / len(df))
            
            status_text.empty()
            progress_bar.empty()
            
            if updated_count > 0:
                st.success(f"✅ Updated eBay prices for {updated_count} records!")
                st.session_state.records_updated += 1
                st.rerun()
            else:
                st.warning("No eBay prices were updated. Check debug tab for details.")
                
        except Exception as e:
            st.error(f"Error updating eBay prices: {e}")

    def _export_ebay_list(self):
        """Export selected records as eBay draft listings"""
        if not st.session_state.selected_records:
            st.warning("Please select records first using the checkboxes in the table.")
            return
        
        try:
            # Get selected records data
            selected_ids = st.session_state.selected_records
            placeholders = ','.join(['?'] * len(selected_ids))
            
            conn = st.session_state.db_manager._get_connection()
            df = pd.read_sql(f'SELECT * FROM records WHERE id IN ({placeholders}) AND status = "inventory"', conn, params=selected_ids)
            conn.close()
            
            records_list = df.to_dict('records')
            
            # Generate eBay formatted TXT
            draft_handler = DraftCSVHandler()
            ebay_content = draft_handler.generate_ebay_txt_from_records(records_list, self.price_handler)
            
            # Create download button
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"ebay_drafts_{timestamp}.txt"
            
            st.download_button(
                label="⬇️ Download eBay Drafts",
                data=ebay_content,
                file_name=filename,
                mime="text/plain",
                key=f"download_ebay_{timestamp}"
            )
            
            st.success(f"✅ eBay draft file ready! {len(records_list)} records formatted for eBay import.")
                
        except Exception as e:
            st.error(f"Error generating eBay list: {e}")

    def _get_database_stats_direct(self, status='inventory') -> Dict:
        """Get database statistics directly from records table"""
        try:
            conn = st.session_state.db_manager._get_connection()
            cursor = conn.cursor()
            
            cursor.execute('SELECT COUNT(*) FROM records WHERE status = ?', (status,))
            records_count_result = cursor.fetchone()
            records_count = records_count_result[0] if records_count_result else 0
            
            cursor.execute('SELECT COUNT(*) FROM records WHERE status = ? AND (barcode IS NULL OR barcode = "")', (status,))
            no_barcode_result = cursor.fetchone()
            no_barcode_count = no_barcode_result[0] if no_barcode_result else 0
            
            cursor.execute('SELECT COUNT(*) FROM records WHERE status = ? AND (file_at IS NULL OR file_at = "")', (status,))
            no_file_at_result = cursor.fetchone()
            no_file_at_count = no_file_at_result[0] if no_file_at_result else 0
            
            cursor.execute('SELECT COUNT(*) FROM records WHERE status = ? AND (ebay_median_price IS NULL OR ebay_median_price = 0)', (status,))
            no_ebay_price_result = cursor.fetchone()
            no_ebay_price_count = no_ebay_price_result[0] if no_ebay_price_result else 0
            
            cursor.execute('SELECT COUNT(*) FROM records WHERE status = ? AND price_tag_printed = 0', (status,))
            price_tags_not_printed_result = cursor.fetchone()
            price_tags_not_printed_count = price_tags_not_printed_result[0] if price_tags_not_printed_result else 0
            
            conn.close()
            
            return {
                'records_count': int(records_count) if records_count is not None else 0,
                'no_barcode_count': int(no_barcode_count) if no_barcode_count is not None else 0,
                'no_file_at_count': int(no_file_at_count) if no_file_at_count is not None else 0,
                'no_ebay_price_count': int(no_ebay_price_count) if no_ebay_price_count is not None else 0,
                'price_tags_not_printed_count': int(price_tags_not_printed_count) if price_tags_not_printed_count is not None else 0
            }
        except Exception as e:
            st.error(f"Error getting stats: {e}")
            return {'records_count': 0, 'no_barcode_count': 0, 'no_file_at_count': 0, 'no_ebay_price_count': 0, 'price_tags_not_printed_count': 0}

    def _get_all_records_direct(self, status: str, search_term: str = None, filter_option: str = None) -> pd.DataFrame:
        """Get all records directly from records table with optional filtering"""
        try:
            conn = st.session_state.db_manager._get_connection()
            
            # Simple query - only from records table with correct column names
            base_query = """
            SELECT 
                id, artist, title, 
                discogs_median_price, discogs_lowest_price, discogs_highest_price,
                ebay_median_price, ebay_lowest_price, ebay_highest_price,
                image_url, barcode, format, condition, created_at, genre, file_at, price_tag_printed, price
            FROM records 
            WHERE status = ?
            """
            
            params = [status]
            
            # Apply search filter
            if search_term:
                base_query += """
                AND (artist LIKE ? 
                    OR title LIKE ? 
                    OR barcode LIKE ?)
                """
                search_pattern = f"%{search_term}%"
                params.extend([search_pattern, search_pattern, search_pattern])
            
            # Apply quick filters
            if filter_option == "No Barcode":
                base_query += " AND (barcode IS NULL OR barcode = '')"
            elif filter_option == "No Price Data":
                base_query += " AND (discogs_median_price IS NULL OR discogs_median_price = 0)"
            elif filter_option == "No Genre":
                base_query += " AND (genre IS NULL OR genre = '')"
            elif filter_option == "No File At":
                base_query += " AND (file_at IS NULL OR file_at = '')"
            elif filter_option == "No eBay Price":
                base_query += " AND (ebay_median_price IS NULL OR ebay_median_price = 0)"
            elif filter_option == "Price Tags Not Printed":
                base_query += " AND price_tag_printed = 0"
            
            # FIXED: Proper numerical sorting for ALL price columns with NULLs at bottom
            base_query += """ 
            ORDER BY 
                CASE 
                    WHEN ebay_median_price IS NULL OR ebay_median_price = '' OR ebay_median_price = 0 THEN 999999
                    ELSE CAST(ebay_median_price AS REAL)
                END ASC,
                CASE 
                    WHEN discogs_median_price IS NULL OR discogs_median_price = '' OR discogs_median_price = 0 THEN 999999
                    ELSE CAST(discogs_median_price AS REAL)
                END ASC,
                CASE 
                    WHEN ebay_lowest_price IS NULL OR ebay_lowest_price = '' OR ebay_lowest_price = 0 THEN 999999
                    ELSE CAST(ebay_lowest_price AS REAL)
                END ASC,
                CASE 
                    WHEN ebay_highest_price IS NULL OR ebay_highest_price = '' OR ebay_highest_price = 0 THEN 999999
                    ELSE CAST(ebay_highest_price AS REAL)
                END ASC,
                CASE 
                    WHEN discogs_lowest_price IS NULL OR discogs_lowest_price = '' OR discogs_lowest_price = 0 THEN 999999
                    ELSE CAST(discogs_lowest_price AS REAL)
                END ASC,
                CASE 
                    WHEN discogs_highest_price IS NULL OR discogs_highest_price = '' OR discogs_highest_price = 0 THEN 999999
                    ELSE CAST(discogs_highest_price AS REAL)
                END ASC
            """
            
            df = pd.read_sql_query(base_query, conn, params=params)
            conn.close()
            return df
            
        except Exception as e:
            st.error(f"Error loading records: {e}")
            return pd.DataFrame()

    def _get_total_filtered_count(self, status: str, search_term: str = None, filter_option: str = None) -> int:
        """Get total count of records after applying filters"""
        try:
            conn = st.session_state.db_manager._get_connection()
            cursor = conn.cursor()
            
            base_query = "SELECT COUNT(*) FROM records WHERE status = ?"
            params = [status]
            
            if search_term:
                base_query += """
                AND (artist LIKE ? 
                    OR title LIKE ? 
                    OR barcode LIKE ?)
                """
                search_pattern = f"%{search_term}%"
                params.extend([search_pattern, search_pattern, search_pattern])
            
            if filter_option == "No Barcode":
                base_query += " AND (barcode IS NULL OR barcode = '')"
            elif filter_option == "No Price Data":
                base_query += " AND (discogs_median_price IS NULL OR discogs_median_price = 0)"
            elif filter_option == "No Genre":
                base_query += " AND (genre IS NULL OR genre = '')"
            elif filter_option == "No File At":
                base_query += " AND (file_at IS NULL OR file_at = '')"
            elif filter_option == "No eBay Price":
                base_query += " AND (ebay_median_price IS NULL OR ebay_median_price = 0)"
            elif filter_option == "Price Tags Not Printed":
                base_query += " AND price_tag_printed = 0"
            
            cursor.execute(base_query, params)
            count_result = cursor.fetchone()
            count = count_result[0] if count_result else 0
            conn.close()
            return int(count) if count is not None else 0
            
        except Exception as e:
            st.error(f"Error counting records: {e}")
            return 0

    def _render_records_table(self, status, search_term, filter_option):
        """Render records with pagination"""
        
        # Get current filter state
        search_term = st.session_state.get(f'search_{status}', '')
        filter_option = st.session_state.get(f'quick_filter_{status}', 'All Records')
        
        # Get total count for pagination
        total_records = self._get_total_filtered_count(status, search_term, filter_option)
        
        if total_records == 0:
            st.info("No records found matching your criteria.")
            return
        
        # Load all records (no pagination)
        records = self._get_all_records_direct(status, search_term, filter_option)
        
        # Display record count
        if search_term:
            st.write(f"**Showing {len(records)} of {total_records} {status} records matching '{search_term}'**")
        elif filter_option != "All Records":
            st.write(f"**Showing {len(records)} of {total_records} {status} {filter_option.lower()}**")
        else:
            st.write(f"**Showing {len(records)} {status} records**")
        
        # Render the records table with selection
        self._render_records_dataframe(records, status)

    def _render_records_dataframe(self, records: pd.DataFrame, status: str):
        """Render records in an optimized dataframe with selection"""
        if len(records) == 0:
            return
        
        # Initialize selection state
        if 'selected_records' not in st.session_state:
            st.session_state.selected_records = []
        
        # Prepare display data with selection
        display_data = []
        for _, record in records.iterrows():
            is_selected = record['id'] in st.session_state.selected_records
            price_tag_status = "✅" if record.get('price_tag_printed') else "❌"
            
            # Calculate eBay price for display
            ebay_price = self.price_handler.calculate_ebay_price(record.get('ebay_lowest_price'))
            
            display_data.append({
                'Select': is_selected,
                'Price Tag': price_tag_status,
                'Cover': record.get('image_url', ''),
                'Artist': record.get('artist', ''),
                'Title': record.get('title', ''),
                'Genre': record.get('genre', ''),  # Added Genre column
                'Barcode': record.get('barcode', ''),
                'File At': record.get('file_at', ''),
                'Condition': record.get('condition', ''),
                'Format': record.get('format', ''),
                'Store Price': self._format_currency(record.get('price')),  # Store price from database
                'eBay Price': self._format_currency(ebay_price),  # Calculated eBay price
                'Discogs Median': self._format_currency(record.get('discogs_median_price')),
                'eBay Lowest': self._format_currency(record.get('ebay_lowest_price')),
                'Added': record.get('created_at', '')[:16] if record.get('created_at') else ''
            })
        
        display_df = pd.DataFrame(display_data)
        
        # Configure columns for better display
        column_config = {
            'Select': st.column_config.CheckboxColumn('Select', width='small'),
            'Price Tag': st.column_config.TextColumn('Price Tag', width='small'),
            'Cover': st.column_config.ImageColumn('Cover', width='small'),
            'Artist': st.column_config.TextColumn('Artist', width='medium'),
            'Title': st.column_config.TextColumn('Title', width='large'),
            'Genre': st.column_config.TextColumn('Genre', width='medium'),  # Added Genre column
            'Barcode': st.column_config.TextColumn('Barcode', width='small'),
            'File At': st.column_config.TextColumn('File At', width='small'),
            'Condition': st.column_config.TextColumn('Condition', width='small'),
            'Format': st.column_config.TextColumn('Format', width='small'),
            'Store Price': st.column_config.TextColumn('Store Price', width='small'),
            'eBay Price': st.column_config.TextColumn('eBay Price', width='small'),
            'Discogs Median': st.column_config.TextColumn('Discogs Median', width='small'),
            'eBay Lowest': st.column_config.TextColumn('eBay Lowest', width='small'),
            'Added': st.column_config.TextColumn('Added', width='small'),
        }
        
        # Add select all checkbox
        col1, col2 = st.columns([1, 5])
        with col1:
            all_selected = st.checkbox("Select All", key=f"select_all_{status}")
        
        # Display editable dataframe with selection
        edited_df = st.data_editor(
            display_df,
            column_config=column_config,
            use_container_width=True,
            height=min(600, 35 * len(display_df) + 40),
            hide_index=True,
            key=f"records_editor_{status}"
        )
        
        # Handle select all functionality
        if all_selected:
            selected_ids = records['id'].tolist()
        else:
            selected_ids = []
            for i, (_, original_record) in enumerate(records.iterrows()):
                if i < len(edited_df) and edited_df.iloc[i]['Select']:
                    selected_ids.append(original_record['id'])
        
        # Update selection state based on editor changes
        if set(selected_ids) != set(st.session_state.selected_records):
            st.session_state.selected_records = selected_ids
            st.rerun()

    def _delete_selected_records(self):
        """Delete selected records"""
        if not st.session_state.selected_records:
            st.warning("Please select records first using the checkboxes in the table.")
            return
            
        try:
            selected_ids = st.session_state.selected_records
            if self._delete_records(selected_ids):
                st.success(f"Deleted {len(selected_ids)} records!")
                # Clear selection after deletion
                st.session_state.selected_records = []
                st.session_state.records_updated += 1
                st.rerun()
        except Exception as e:
            st.error(f"Error deleting records: {e}")

    def _format_currency(self, value):
        """Format currency values"""
        if not value:
            return "$N/A"
        try:
            return f"${float(value):.2f}"
        except (ValueError, TypeError):
            return "$N/A"

    def _delete_records(self, record_ids):
        """Delete records from the database"""
        try:
            conn = st.session_state.db_manager._get_connection()
            cursor = conn.cursor()
            cursor.executemany('DELETE FROM records WHERE id = ?', [(id,) for id in record_ids])
            conn.commit()
            conn.close()
            return True
        except Exception as e:
            st.error(f"Error deleting records: {e}")
            return False

    def _generate_barcodes_for_existing_records(self):
        """Generate barcodes for records without them"""
        if not st.session_state.selected_records:
            st.warning("Please select records first using the checkboxes in the table.")
            return
            
        try:
            selected_ids = st.session_state.selected_records
            placeholders = ','.join(['?'] * len(selected_ids))
            
            conn = st.session_state.db_manager._get_connection()
            cursor = conn.cursor()
            
            cursor.execute(f'SELECT id FROM records WHERE id IN ({placeholders}) AND (barcode IS NULL OR barcode = "" OR barcode NOT GLOB "[0-9]*")', selected_ids)
            records_without_barcodes = cursor.fetchall()
            
            cursor.execute('SELECT MAX(CAST(barcode AS INTEGER)) as max_barcode FROM records WHERE barcode GLOB "[0-9]*"')
            result = cursor.fetchone()
            current_max = result[0] if result[0] is not None else 100000
            
            updated_count = 0
            for record in records_without_barcodes:
                record_id = record[0]
                current_max += 1
                # Use update_record to track changes properly
                success = st.session_state.db_manager.update_record(record_id, {'barcode': str(current_max)})
                if success:
                    updated_count += 1
            
            conn.close()
            
            if updated_count > 0:
                st.success(f"✅ Generated barcodes for {updated_count} records!")
            else:
                st.info("✅ All selected records already have barcodes!")
                
            st.session_state.records_updated += 1
            st.rerun()
            
        except Exception as e:
            st.error(f"Error generating barcodes: {e}")

    def _generate_file_at_for_selected_records(self):
        """Generate file_at values for selected records"""
        if not st.session_state.selected_records:
            st.warning("Please select records first using the checkboxes in the table.")
            return
            
        try:
            selected_ids = st.session_state.selected_records
            placeholders = ','.join(['?'] * len(selected_ids))
            
            conn = st.session_state.db_manager._get_connection()
            df = pd.read_sql(f'SELECT * FROM records WHERE id IN ({placeholders})', conn, params=selected_ids)
            conn.close()
            
            updated_count = 0
            for _, record in df.iterrows():
                artist = record.get('artist', '')
                genre = record.get('genre', 'Unknown')
                file_at_letter = self._calculate_file_at(artist)
                file_at = f"{genre}({file_at_letter})"
                
                # Use update_record to track changes properly
                success = st.session_state.db_manager.update_record(record['id'], {'file_at': file_at})
                if success:
                    updated_count += 1
            
            if updated_count > 0:
                st.success(f"✅ Regenerated file_at for {updated_count} records!")
                st.session_state.records_updated += 1
                st.rerun()
            else:
                st.info("✅ File_at values updated!")
                
        except Exception as e:
            st.error(f"Error generating file_at values: {e}")

    def _generate_price_tags_pdf(self):
        """Generate price tags PDF for selected records"""
        if not st.session_state.selected_records:
            st.warning("Please select records first using the checkboxes in the table.")
            return
        
        try:
            # Get selected records data
            selected_ids = st.session_state.selected_records
            placeholders = ','.join(['?'] * len(selected_ids))
            
            conn = st.session_state.db_manager._get_connection()
            df = pd.read_sql(f'SELECT * FROM records WHERE id IN ({placeholders}) AND status = "inventory"', conn, params=selected_ids)
            conn.close()
            
            records_list = df.to_dict('records')
            pdf_buffer = self._generate_price_tags_pdf_for_records(records_list)
            
            # Mark price tags as printed
            st.session_state.db_manager.mark_price_tags_printed(selected_ids)
            
            st.download_button(
                label="⬇️ Download Price Tags PDF",
                data=pdf_buffer.getvalue(),
                file_name=f"price_tags_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf",
                mime="application/pdf"
            )
            
            st.success(f"✅ Price tags PDF ready! {len(records_list)} records marked as printed.")
            st.session_state.records_updated += 1
            
        except Exception as e:
            st.error(f"Error generating price tags: {e}")

    def _generate_price_tags_pdf_for_records(self, records):
        """Generate PDF with price tags for given records"""
        buffer = io.BytesIO()
        c = canvas.Canvas(buffer, pagesize=letter)
        
        # Calculate positions
        array_positions = []
        for array_num in range(4):
            x_start = self.left_margin + (array_num * (self.label_width + self.gutter_spacing))
            array_positions.append(x_start)
        
        # Draw price tags
        self._draw_price_tags(c, records, array_positions, self.top_margin)
        
        c.save()
        buffer.seek(0)
        return buffer

    def _draw_price_tags(self, c, records, array_positions, top_margin):
        """Draw price tags with record information"""
        current_label = 0
        total_labels = len(records)
        
        for array_num, x_start in enumerate(array_positions):
            for row in range(15):
                if current_label >= total_labels:
                    break
                
                y_pos = self.page_height - top_margin - (row * self.label_height)
                
                c.setStrokeColorRGB(0, 0, 0)
                c.setLineWidth(0.25)
                c.rect(x_start, y_pos - self.label_height, self.label_width, self.label_height)
                
                record = records[current_label]
                self._draw_label_content(c, record, x_start, y_pos)
                
                current_label += 1
            
            if current_label >= total_labels:
                break
        
        while current_label < total_labels:
            c.showPage()
            current_label = self._draw_next_page(c, records, current_label)

    def _draw_next_page(self, c, records, start_index):
        """Draw additional page with price tags"""
        array_positions = []
        for array_num in range(4):
            x_start = self.left_margin + (array_num * (self.label_width + self.gutter_spacing))
            array_positions.append(x_start)
        
        current_label = start_index
        total_labels = len(records)
        
        for array_num, x_start in enumerate(array_positions):
            for row in range(15):
                if current_label >= total_labels:
                    return current_label
                
                y_pos = self.page_height - self.top_margin - (row * self.label_height)
                
                c.setStrokeColorRGB(0, 0, 0)
                c.setLineWidth(0.25)
                c.rect(x_start, y_pos - self.label_height, self.label_width, self.label_height)
                
                record = records[current_label]
                self._draw_label_content(c, record, x_start, y_pos)
                
                current_label += 1
        
        return current_label

    def _draw_label_content(self, c, record, x, y):
        """Draw content for a single price tag"""
        padding = 2
        content_width = self.label_width - (2 * padding)
        font_size = self.font_size
        
        # Artist/title abbreviation
        artist = record.get('artist', '')
        title = record.get('title', '')
        abbreviation = self._create_abbreviation(artist, title)
        
        # Price - use store price from database
        price = record.get('price', 0)
        if price:
            c.setFont("Helvetica-Bold", font_size + 2)
            price_text = f"${float(price):.2f}"
            c.drawString(x + padding, y - 10, price_text)
        
        # Date
        c.setFont("Helvetica", font_size - 1)
        date_text = datetime.now().strftime("%m/%d/%y")
        date_width = c.stringWidth(date_text, "Helvetica", font_size - 1)
        c.drawString(x + self.label_width - date_width - padding, y - 10, date_text)
        
        # Artist/title
        if abbreviation:
            c.setFont("Helvetica", font_size - 1)
            if c.stringWidth(abbreviation, "Helvetica", font_size - 1) > content_width:
                abbreviation = self._truncate_text(c, abbreviation, content_width, font_size - 1)
            c.drawString(x + padding, y - 20, abbreviation)
        
        # File location string - right of artist-title field
        file_at = record.get('file_at', '')
        if file_at:
            c.setFont("Helvetica-Bold", font_size)
            location_width = c.stringWidth(file_at, "Helvetica-Bold", font_size)
            c.drawString(x + self.label_width - location_width - padding, y - 20, file_at)
        
        # Barcode
        barcode = record.get('barcode', '')
        if barcode:
            try:
                barcode_obj = code128.Code128(barcode, barWidth=0.4*mm, barHeight=4*mm)
                barcode_x = x + padding - (5 * mm)
                barcode_y = y - 42 - (1.5 * mm)
                barcode_obj.drawOn(c, barcode_x, barcode_y)
            except:
                c.setFont("Helvetica", font_size - 2)
                barcode_text = f"#{barcode}"
                barcode_x = x + padding - (5 * mm)
                barcode_y = y - 42 - (1.5 * mm)
                c.drawString(barcode_x, barcode_y, barcode_text)

    def _create_abbreviation(self, artist, title):
        """Create abbreviation from artist and title"""
        if not artist and not title:
            return ""
        
        artist_words = artist.split()[:3]
        title_words = title.split()[:2]
        
        abbreviation = ""
        if artist_words:
            abbreviation = " ".join(artist_words)
        if title_words:
            if abbreviation:
                abbreviation += " - "
            abbreviation += " ".join(title_words)
        
        if len(abbreviation) > 25:
            abbreviation = abbreviation[:22] + "..."
        
        return abbreviation

    def _truncate_text(self, c, text, max_width, font_size):
        """Truncate text to fit within max width"""
        font_name = "Helvetica"
        if c.stringWidth(text, font_name, font_size) <= max_width:
            return text
        
        low, high = 0, len(text)
        while low < high:
            mid = (low + high) // 2
            test_text = text[:mid] + "..."
            if c.stringWidth(test_text, font_name, font_size) <= max_width:
                low = mid + 1
            else:
                high = mid
        
        return text[:low-1] + "..."

======================================================================

FILE: inventory-manager/src/tabs/genre_mappings_tab.py
--------------------------------------------------
import streamlit as st
import pandas as pd
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
import io
import os
import json
from datetime import datetime

class PrintConfig:
    def __init__(self, config_file="print_config.json"):
        self.config_file = config_file
        self.defaults = {
            "last_genre": "",
            "genre_font_size": 48
        }
        self.config = self._load_config()
    
    def _load_config(self):
        """Load configuration from file or use defaults"""
        if os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r') as f:
                    loaded_config = json.load(f)
                    # Merge with defaults to ensure all keys exist
                    config = self.defaults.copy()
                    config.update(loaded_config)
                    return config
            except Exception as e:
                print(f"Error loading config file: {e}. Using defaults.")
                return self.defaults.copy()
        else:
            # Create default config file
            self._save_config(self.defaults)
            return self.defaults.copy()
    
    def _save_config(self, config):
        """Save configuration to file"""
        try:
            with open(self.config_file, 'w') as f:
                json.dump(config, f, indent=2)
        except Exception as e:
            print(f"Error saving config file: {e}")
    
    def get(self, key, default=None):
        """Get a configuration value with optional default"""
        return self.config.get(key, default if default is not None else self.defaults.get(key))
    
    def update(self, new_config):
        """Update configuration and save to file"""
        self.config.update(new_config)
        self._save_config(self.config)
    
    def get_all(self):
        """Get all configuration values"""
        return self.config.copy()

class GenreMappingsTab:
    def __init__(self):
        self.config = PrintConfig()
    
    def render(self):
        st.header("🎵 Genres")
        
        try:
            # Check if database manager is available
            if not hasattr(st.session_state, 'db_manager'):
                st.error("Database manager not initialized")
                return
            
            # Initialize session state for tracking processed files
            if 'last_processed_file' not in st.session_state:
                st.session_state.last_processed_file = None
            
            # Get all artists from records and their assigned genres
            all_artists_with_genres = st.session_state.db_manager.get_all_artists_with_genres()
            
            # Get all genres for dropdown
            all_genres = st.session_state.db_manager.get_all_genres()
            genre_options = {row['genre_name']: row['id'] for _, row in all_genres.iterrows()}
            
            if len(all_artists_with_genres) > 0:
                st.subheader("Artist-Genre Assignments")
                
                # Add filters
                col1, col2 = st.columns(2)
                with col1:
                    artist_filter = st.text_input(
                        "Filter by artist:",
                        placeholder="Enter artist name...",
                        key="artist_filter"
                    )
                with col2:
                    genre_filter = st.selectbox(
                        "Filter by genre:",
                        options=["All Genres"] + list(genre_options.keys()),
                        key="genre_filter"
                    )
                
                # Apply filters
                filtered_artists = all_artists_with_genres.copy()
                if artist_filter:
                    filtered_artists = filtered_artists[filtered_artists['artist_name'].str.contains(artist_filter, case=False, na=False)]
                if genre_filter != "All Genres":
                    filtered_artists = filtered_artists[filtered_artists['genre_name'] == genre_filter]
                
                # Create editable dataframe
                display_data = []
                for _, row in filtered_artists.iterrows():
                    display_data.append({
                        'Artist': row['artist_name'],
                        'Genre': row['genre_name'] if row['genre_name'] else "Unknown"
                    })
                
                df = pd.DataFrame(display_data)
                
                # Create editable dataframe with selectbox for genre
                edited_df = st.data_editor(
                    df,
                    column_config={
                        'Artist': st.column_config.TextColumn('Artist', disabled=True),
                        'Genre': st.column_config.SelectboxColumn(
                            'Genre',
                            options=[""] + list(genre_options.keys()),
                            required=False
                        )
                    },
                    use_container_width=True,
                    hide_index=True,
                    key="genre_mappings_editor"
                )
                
                # Update genre assignments if changes were made
                if not edited_df.equals(df):
                    changes_made = False
                    for i, (original_row, edited_row) in enumerate(zip(df.to_dict('records'), edited_df.to_dict('records'))):
                        if original_row['Genre'] != edited_row['Genre']:
                            artist_name = original_row['Artist']
                            if edited_row['Genre']:  # Only update if a genre is selected
                                new_genre_name = edited_row['Genre']
                                # Check if genre exists, if not create it
                                if new_genre_name not in genre_options:
                                    success, new_genre_id = st.session_state.db_manager.add_genre(new_genre_name)
                                    if success:
                                        genre_options[new_genre_name] = new_genre_id
                                    else:
                                        st.error(f"Failed to create new genre: {new_genre_name}")
                                        continue
                                else:
                                    new_genre_id = genre_options[new_genre_name]
                                
                                success = st.session_state.db_manager.assign_genre_to_artist(artist_name, new_genre_id)
                                if success:
                                    changes_made = True
                            else:
                                # Remove genre assignment if empty string selected
                                success = st.session_state.db_manager.remove_genre_from_artist_by_name(artist_name)
                                if success:
                                    changes_made = True
                    
                    if changes_made:
                        st.success("Genre assignments updated!")
                        st.rerun()
                
                # Export/Import functionality
                col1, col2 = st.columns(2)
                
                with col1:
                    if st.button("📤 Export Genre Data", use_container_width=True):
                        # Export only artist mappings
                        export_data = self._prepare_export_data(edited_df)
                        csv_data = export_data.to_csv(index=False)
                        
                        st.download_button(
                            label="⬇️ Download Genre CSV",
                            data=csv_data,
                            file_name="genre_data_export.csv",
                            mime="text/csv",
                            key="download_genre_data"
                        )
                
                with col2:
                    uploaded_file = st.file_uploader(
                        "Import genre data CSV",
                        type=['csv'],
                        help="Upload CSV with artist-genre mappings",
                        key="genre_import_uploader"
                    )
                    
                    # Only process if we have a new uploaded file and haven't processed it yet
                    if (uploaded_file is not None and 
                        st.session_state.last_processed_file != uploaded_file.file_id):
                        
                        try:
                            # Store that we're processing this file
                            st.session_state.last_processed_file = uploaded_file.file_id
                            
                            import_df = pd.read_csv(uploaded_file)
                            updates_made = self._process_import_data_fast(import_df)
                            
                            if updates_made > 0:
                                st.success(f"✅ Imported {updates_made} genre updates!")
                                # Clear the uploader by resetting the session state
                                if 'genre_import_uploader' in st.session_state:
                                    del st.session_state.genre_import_uploader
                                st.rerun()
                            else:
                                st.warning("No valid genre updates found in file")
                                # Clear the uploader
                                if 'genre_import_uploader' in st.session_state:
                                    del st.session_state.genre_import_uploader
                        except Exception as e:
                            st.error(f"Error importing CSV: {e}")
                            # Clear the uploader on error too
                            if 'genre_import_uploader' in st.session_state:
                                del st.session_state.genre_import_uploader
            
            else:
                st.info("No artists found in records.")
            
            # Clean up unused genres
            st.subheader("Clean Up Genres")
            if st.button("🗑️ Remove Unused Genres", help="Delete genres that are not assigned to any artists"):
                unused_genres_removed = self._remove_unused_genres()
                if unused_genres_removed > 0:
                    st.success(f"✅ Removed {unused_genres_removed} unused genres!")
                    st.rerun()
                else:
                    st.info("No unused genres found.")
            
            # Genre Signs Printing
            st.subheader("Genre Signs Printing")
            
            if len(all_genres) > 0:
                genre_options_list = all_genres['genre_name'].tolist()
            else:
                genre_options_list = ["ROCK", "JAZZ", "HIP-HOP", "ELECTRONIC", "POP", "METAL", "FOLK", "SOUL"]
            
            col1, col2 = st.columns(2)
            with col1:
                print_option = st.radio(
                    "Print option:",
                    ["Single Genre", "All Genres"],
                    key="print_option"
                )
                
                if print_option == "Single Genre":
                    genre_text = st.selectbox("Select genre:", options=genre_options_list, key="genre_select")
                else:
                    genre_text = "ALL_GENRES"
            
            with col2:
                font_size = st.slider("Font Size", min_value=24, max_value=96, value=48, key="genre_font_size")
            
            if st.button("🖨️ Generate Genre Sign PDF"):
                try:
                    if print_option == "All Genres":
                        pdf_buffer = self._generate_all_genre_signs_pdf(genre_options_list, font_size)
                        filename = f"all_genre_signs_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
                    else:
                        pdf_buffer = self._generate_genre_sign_pdf(genre_text, font_size)
                        filename = f"genre_sign_{genre_text.replace(' ', '_')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
                    
                    st.download_button(
                        label="⬇️ Download Genre Sign PDF",
                        data=pdf_buffer.getvalue(),
                        file_name=filename,
                        mime="application/pdf"
                    )
                except Exception as e:
                    st.error(f"Error generating genre sign: {e}")
                
        except Exception as e:
            st.error(f"Error loading genres: {e}")

    def _prepare_export_data(self, artist_mappings_df):
        """Prepare export data with only artist mappings"""
        # Prepare artist mapping data (include unknown genres)
        artist_mapping_data = []
        for _, row in artist_mappings_df.iterrows():
            artist_mapping_data.append({
                'Artist': row['Artist'],
                'Genre': row['Genre'] if row['Genre'] else 'Unknown'
            })
        
        # Combine both datasets
        export_df = pd.DataFrame(artist_mapping_data)
        return export_df

    def _process_import_data_fast(self, import_df):
        """Process imported genre data with bulk operations and progress bar"""
        # Normalize column names to handle case differences
        column_mapping = {}
        for col in import_df.columns:
            col_lower = col.lower()
            if col_lower == 'artist':
                column_mapping[col] = 'artist'
            elif col_lower == 'genre':
                column_mapping[col] = 'genre'
        
        # Rename columns to standardize
        import_df_standardized = import_df.rename(columns=column_mapping)
        
        # Check if we have the required columns
        if 'artist' not in import_df_standardized.columns or 'genre' not in import_df_standardized.columns:
            st.error("CSV must contain 'Artist' and 'Genre' columns")
            return 0
        
        # Filter valid rows
        valid_rows = []
        for _, row in import_df_standardized.iterrows():
            artist = row['artist']
            genre_name = row['genre']
            if artist and genre_name and pd.notna(artist) and pd.notna(genre_name) and genre_name != 'Unknown':
                valid_rows.append((artist, genre_name))
        
        if not valid_rows:
            st.warning("No valid artist-genre pairs found in file")
            return 0
        
        # Setup progress tracking
        progress_bar = st.progress(0)
        status_text = st.empty()
        total_rows = len(valid_rows)
        
        try:
            conn = st.session_state.db_manager._get_connection()
            cursor = conn.cursor()
            
            # Step 1: Get all existing genres
            cursor.execute('SELECT id, genre_name FROM genres')
            existing_genres = {row[1]: row[0] for row in cursor.fetchall()}
            
            # Step 2: Find genres that need to be created
            unique_genres = set(genre for _, genre in valid_rows)
            genres_to_create = unique_genres - set(existing_genres.keys())
            
            # Step 3: Bulk create new genres
            if genres_to_create:
                status_text.text("Creating new genres...")
                for i, genre_name in enumerate(genres_to_create):
                    cursor.execute('INSERT INTO genres (genre_name) VALUES (?)', (genre_name,))
                    existing_genres[genre_name] = cursor.lastrowid
                    progress_bar.progress((i + 1) / (len(genres_to_create) + total_rows) * 0.3)
            
            # Step 4: Bulk assign genres to artists
            status_text.text("Assigning genres to artists...")
            assignments_made = 0
            
            for i, (artist, genre_name) in enumerate(valid_rows):
                genre_id = existing_genres[genre_name]
                
                # Use INSERT OR REPLACE to handle existing assignments
                cursor.execute('''
                    INSERT OR REPLACE INTO genre_by_artist (artist_name, genre_id)
                    VALUES (?, ?)
                ''', (artist, genre_id))
                
                assignments_made += 1
                
                # Update progress
                progress = 0.3 + ((i + 1) / total_rows * 0.7)
                progress_bar.progress(progress)
                status_text.text(f"Processing {i+1}/{total_rows}: {artist} → {genre_name}")
            
            conn.commit()
            conn.close()
            
            status_text.text(f"✅ Completed! Processed {assignments_made} assignments")
            progress_bar.progress(1.0)
            
            return assignments_made
            
        except Exception as e:
            st.error(f"Error during import: {e}")
            return 0
        finally:
            # Clean up progress indicators after a delay
            import time
            time.sleep(2)
            progress_bar.empty()
            status_text.empty()

    def _process_import_data(self, import_df):
        """Legacy slow import method - kept for compatibility"""
        return self._process_import_data_fast(import_df)

    def _remove_unused_genres(self):
        """Remove genres that are not assigned to any artists"""
        try:
            conn = st.session_state.db_manager._get_connection()
            cursor = conn.cursor()
            
            # Find genres with no artist assignments
            cursor.execute('''
                SELECT g.id, g.genre_name 
                FROM genres g 
                LEFT JOIN genre_by_artist gba ON g.id = gba.genre_id 
                WHERE gba.genre_id IS NULL
            ''')
            
            unused_genres = cursor.fetchall()
            removed_count = 0
            
            # Delete unused genres
            for genre_id, genre_name in unused_genres:
                cursor.execute('DELETE FROM genres WHERE id = ?', (genre_id,))
                removed_count += 1
            
            conn.commit()
            conn.close()
            
            return removed_count
            
        except Exception as e:
            st.error(f"Error removing unused genres: {e}")
            return 0

    def _generate_genre_sign_pdf(self, genre, font_size):
        """Generate PDF with genre sign"""
        buffer = io.BytesIO()
        page_width, page_height = letter
        c = canvas.Canvas(buffer, pagesize=(page_width, page_height))
        
        text = genre.upper()
        font_name = "Helvetica-Bold"
        
        c.setFont(font_name, font_size)
        text_width = c.stringWidth(text, font_name, font_size)
        text_height = font_size
        
        x_center = page_width / 2
        y_center = page_height / 2
        
        border_padding = 12
        border_width = text_height + (2 * border_padding)
        border_height = text_width + (2 * border_padding)
        border_x = x_center - (border_width / 2)
        border_y = y_center - (border_height / 2)
        
        c.setStrokeColorRGB(0, 0, 0)
        c.setLineWidth(2)
        c.rect(border_x, border_y, border_width, border_height)
        
        c.saveState()
        c.translate(x_center, y_center)
        c.rotate(-90)
        c.setFont(font_name, font_size)
        c.drawString(-text_width/2, -text_height/2, text)
        c.restoreState()
        
        c.save()
        buffer.seek(0)
        return buffer

    def _generate_all_genre_signs_pdf(self, genres, font_size):
        """Generate PDF with all genre signs, one per page"""
        buffer = io.BytesIO()
        page_width, page_height = letter
        c = canvas.Canvas(buffer, pagesize=(page_width, page_height))
        font_name = "Helvetica-Bold"
        
        for i, genre in enumerate(genres):
            if i > 0:  # Start new page for each genre after the first one
                c.showPage()
            
            text = genre.upper()
            
            c.setFont(font_name, font_size)
            text_width = c.stringWidth(text, font_name, font_size)
            text_height = font_size
            
            x_center = page_width / 2
            y_center = page_height / 2
            
            border_padding = 12
            border_width = text_height + (2 * border_padding)
            border_height = text_width + (2 * border_padding)
            border_x = x_center - (border_width / 2)
            border_y = y_center - (border_height / 2)
            
            c.setStrokeColorRGB(0, 0, 0)
            c.setLineWidth(2)
            c.rect(border_x, border_y, border_width, border_height)
            
            c.saveState()
            c.translate(x_center, y_center)
            c.rotate(-90)
            c.setFont(font_name, font_size)
            c.drawString(-text_width/2, -text_height/2, text)
            c.restoreState()
        
        c.save()
        buffer.seek(0)
        return buffer

======================================================================

FILE: inventory-manager/src/tabs/checkout_tab.py
--------------------------------------------------
import streamlit as st
import pandas as pd
from datetime import datetime

class CheckoutTab:
    def __init__(self):
        if 'scanned_records' not in st.session_state:
            st.session_state.scanned_records = []
        if 'barcode_input_key' not in st.session_state:
            st.session_state.barcode_input_key = 0
        if 'receipt_content' not in st.session_state:
            st.session_state.receipt_content = None
        if 'show_receipt_download' not in st.session_state:
            st.session_state.show_receipt_download = False

    def render(self):
        st.header("📦 Checkout")
        
        # Show receipt download if available
        if st.session_state.show_receipt_download and st.session_state.receipt_content:
            st.success("✅ Sale processed! Download your receipt below.")
            st.download_button(
                label="⬇️ Download Receipt",
                data=st.session_state.receipt_content,
                file_name=f"receipt_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt",
                mime="text/plain",
                key="download_receipt"
            )
            if st.button("Clear Receipt", use_container_width=True):
                st.session_state.receipt_content = None
                st.session_state.show_receipt_download = False
                st.rerun()
        
        # Barcode scanner input
        st.subheader("Scan Barcode")
        barcode_input = st.text_input(
            "Enter barcode:",
            placeholder="Scan or enter barcode here...",
            key=f"barcode_input_{st.session_state.barcode_input_key}",
            label_visibility="collapsed"
        )
        
        # Auto-focus the input field
        st.markdown(
            """
            <script>
            var input = window.parent.document.querySelector('input[placeholder="Scan or enter barcode here..."]');
            if (input) input.focus();
            </script>
            """,
            unsafe_allow_html=True
        )
        
        # Process barcode when entered
        if barcode_input and barcode_input.strip():
            self._process_barcode(barcode_input.strip())
            # Clear the input field by incrementing the key
            st.session_state.barcode_input_key += 1
            st.rerun()
        
        # Display scanned records
        st.subheader("Scanned Records")
        
        if st.session_state.scanned_records:
            # Calculate total value
            total_value = sum(record.get('discogs_median_price', 0) or 0 for record in st.session_state.scanned_records)
            
            # Display summary
            col1, col2 = st.columns(2)
            with col1:
                st.metric("Items Scanned", len(st.session_state.scanned_records))
            with col2:
                st.metric("Total Value", f"${total_value:.2f}")
            
            # Display scanned records in a table
            display_data = []
            for record in st.session_state.scanned_records:
                display_data.append({
                    'Artist': record.get('artist', ''),
                    'Title': record.get('title', ''),
                    'Barcode': record.get('barcode', ''),
                    'File At': record.get('file_at', ''),
                    'Price': f"${record.get('discogs_median_price', 0) or 0:.2f}",
                    'Format': record.get('format', ''),
                    'Condition': record.get('condition', '')
                })
            
            df = pd.DataFrame(display_data)
            st.dataframe(df, use_container_width=True, hide_index=True)
            
            # Action buttons - only Print Receipt button
            if st.button("🧾 Print Receipt & Mark as Sold", use_container_width=True):
                self._process_sale()
        else:
            st.info("No records scanned yet. Start scanning barcodes above.")
    
    def _process_barcode(self, barcode):
        """Process a scanned barcode"""
        try:
            # Look up record by barcode
            record = st.session_state.db_manager.get_record_by_barcode(barcode)
            
            if record is not None:
                # Check if record is already in the scanned list
                if any(r.get('barcode') == barcode for r in st.session_state.scanned_records):
                    st.warning(f"Record '{record.get('artist', '')} - {record.get('title', '')}' already scanned!")
                else:
                    # Add to scanned records
                    st.session_state.scanned_records.append(record)
                    st.success(f"✅ Added: {record.get('artist', '')} - {record.get('title', '')}")
            else:
                st.error(f"❌ No record found with barcode: {barcode}")
                
        except Exception as e:
            st.error(f"Error processing barcode: {e}")
    
    def _process_sale(self):
        """Process the sale - mark scanned records as sold"""
        if not st.session_state.scanned_records:
            st.warning("No records to process.")
            return
        
        try:
            # Update records status to 'sold'
            updated_count = 0
            for record in st.session_state.scanned_records:
                record_id = record.get('id')
                if record_id:
                    conn = st.session_state.db_manager._get_connection()
                    cursor = conn.cursor()
                    cursor.execute('UPDATE records SET status = ? WHERE id = ?', ('sold', record_id))
                    conn.commit()
                    conn.close()
                    updated_count += 1
            
            if updated_count > 0:
                # Generate receipt
                receipt_content = self._generate_receipt_content()
                st.session_state.receipt_content = receipt_content
                st.session_state.show_receipt_download = True
                
                # Clear scanned records
                st.session_state.scanned_records = []
                st.session_state.records_updated += 1
                st.rerun()
            else:
                st.error("Failed to update any records.")
                
        except Exception as e:
            st.error(f"Error processing sale: {e}")
    
    def _generate_receipt_content(self):
        """Generate receipt content for the scanned records"""
        try:
            # Create receipt content
            receipt_lines = []
            receipt_lines.append("PIGSTYLE RECORDS - CHECKOUT RECEIPT")
            receipt_lines.append("=" * 40)
            receipt_lines.append(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M')}")
            receipt_lines.append(f"Items: {len(st.session_state.scanned_records)}")
            receipt_lines.append("")
            
            total = 0
            for i, record in enumerate(st.session_state.scanned_records, 1):
                artist = record.get('artist', 'Unknown Artist')
                title = record.get('title', 'Unknown Title')
                price = record.get('discogs_median_price', 0) or 0
                total += price
                
                # Truncate long titles for receipt format
                if len(title) > 30:
                    title = title[:27] + "..."
                if len(artist) > 20:
                    artist = artist[:17] + "..."
                
                receipt_lines.append(f"{i:2d}. {artist:<20} {title:<30} ${price:>6.2f}")
            
            receipt_lines.append("")
            receipt_lines.append("=" * 40)
            receipt_lines.append(f"TOTAL: ${total:>33.2f}")
            receipt_lines.append("")
            receipt_lines.append("Thank you for your purchase!")
            
            return "\n".join(receipt_lines)
            
        except Exception as e:
            return f"Error generating receipt: {e}"

======================================================================

FILE: inventory-manager/src/tabs/debug_tab.py
--------------------------------------------------
import streamlit as st
from datetime import datetime

class DebugTab:
    def __init__(self):
        # Initialize session state for logs if not exists
        if 'debug_logs' not in st.session_state:
            st.session_state.debug_logs = []
        
    def add_log(self, category, message, data=None):
        """Add a log entry to the debug tab"""
        timestamp = datetime.now().strftime("%H:%M:%S.%f")[:-3]
        log_entry = {
            'timestamp': timestamp,
            'category': category,
            'message': message,
            'data': data
        }
        st.session_state.debug_logs.append(log_entry)
        # Keep only last 100 entries to prevent memory issues
        if len(st.session_state.debug_logs) > 100:
            st.session_state.debug_logs.pop(0)
    
    def render(self):
        st.header("🔧 Debug Logs")
        
        if not st.session_state.debug_logs:
            st.info("No debug logs yet. Actions will appear here as they happen.")
            return
        
        # Display logs in reverse chronological order
        for log in reversed(st.session_state.debug_logs):
            with st.container():
                col1, col2 = st.columns([1, 4])
                with col1:
                    st.code(log['timestamp'])
                with col2:
                    st.write(f"**{log['category']}**: {log['message']}")
                
                # Show data in expander if available
                if log['data']:
                    with st.expander("View Request/Response Details"):
                        st.json(log['data'])
                
                st.divider()
        
        # Clear logs button
        if st.button("Clear Logs"):
            st.session_state.debug_logs = []
            st.rerun()

======================================================================

FILE: inventory-manager/src/tabs/expenses_tab.py
--------------------------------------------------
import streamlit as st
import pandas as pd
from datetime import datetime
import io

class ExpensesTab:
    def __init__(self):
        pass
    
    def render(self):
        st.header("💰 Expenses")
        
        tab1, tab2 = st.tabs(["➕ Add Expense", "📋 View Expenses"])
        
        with tab1:
            self._render_add_expense()
        
        with tab2:
            self._render_view_expenses()

    def _render_add_expense(self):
        """Render the add expense form"""
        st.subheader("Add New Expense")
        
        with st.form(key="expense_form"):
            description = st.text_input(
                "Description",
                placeholder="Enter expense description..."
            )
            
            amount = st.number_input(
                "Amount",
                min_value=0.0,
                step=0.01,
                format="%.2f",
                help="Enter the expense amount"
            )
            
            # Camera input for receipt photo
            st.write("**Receipt Photo:**")
            camera_input = st.camera_input(
                "Take a photo of the receipt",
                help="Use your camera to take a photo of the receipt"
            )
            
            # File uploader as fallback
            receipt_upload = st.file_uploader(
                "Or upload receipt photo",
                type=['jpg', 'jpeg', 'png'],
                help="Upload a photo of the receipt"
            )
            
            submitted = st.form_submit_button("Save Expense", use_container_width=True)
            
            if submitted:
                if not description:
                    st.error("Please enter a description")
                    return
                
                if amount <= 0:
                    st.error("Please enter a valid amount")
                    return
                
                try:
                    # Use camera input if available, otherwise use file upload
                    receipt_bytes = None
                    if camera_input is not None:
                        receipt_bytes = camera_input.getvalue()
                    elif receipt_upload is not None:
                        receipt_bytes = receipt_upload.getvalue()
                    
                    # Save to database
                    expense_id = st.session_state.db_manager.save_expense(description, amount, receipt_bytes)
                    
                    if expense_id:
                        st.success(f"✅ Expense saved! Amount: ${amount:.2f}")
                        st.rerun()
                    else:
                        st.error("Failed to save expense")
                        
                except Exception as e:
                    st.error(f"Error saving expense: {e}")

    def _render_view_expenses(self):
        """Render the expenses list"""
        st.subheader("Expense History")
        
        try:
            expenses = st.session_state.db_manager.get_all_expenses()
            
            if len(expenses) > 0:
                # Calculate total
                total_amount = expenses['amount'].sum()
                
                # Display summary
                col1, col2 = st.columns(2)
                with col1:
                    st.metric("Total Expenses", f"${total_amount:.2f}")
                with col2:
                    st.metric("Number of Expenses", len(expenses))
                
                # Prepare display data
                display_data = []
                for _, expense in expenses.iterrows():
                    display_data.append({
                        'Date': expense.get('created_at', '')[:16],
                        'Description': expense.get('description', ''),
                        'Amount': f"${expense.get('amount', 0):.2f}",
                        'Receipt': "📷" if expense.get('receipt_image') else "❌"
                    })
                
                display_df = pd.DataFrame(display_data)
                
                # Configure columns
                column_config = {
                    'Date': st.column_config.TextColumn('Date', width='small'),
                    'Description': st.column_config.TextColumn('Description', width='medium'),
                    'Amount': st.column_config.TextColumn('Amount', width='small'),
                    'Receipt': st.column_config.TextColumn('Receipt', width='small'),
                }
                
                st.dataframe(
                    display_df,
                    column_config=column_config,
                    use_container_width=True,
                    hide_index=True
                )
                
                # Export button
                if st.button("📊 Export CSV", use_container_width=True):
                    self._export_expenses(expenses)
                
            else:
                st.info("No expenses recorded yet. Add your first expense above!")
                
        except Exception as e:
            st.error(f"Error loading expenses: {e}")

    def _export_expenses(self, expenses):
        """Export expenses to CSV"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"expenses_export_{timestamp}.csv"
            
            # Create clean export data
            export_data = expenses[['created_at', 'description', 'amount']].copy()
            export_data.columns = ['Date', 'Description', 'Amount']
            export_data['Date'] = export_data['Date'].str[:16]
            
            csv_data = export_data.to_csv(index=False)
            
            st.download_button(
                label="⬇️ Download Expenses CSV",
                data=csv_data,
                file_name=filename,
                mime="text/csv",
                key="download_expenses"
            )
            
            st.success(f"✅ Export ready! {len(expenses)} expenses.")
            
        except Exception as e:
            st.error(f"Error exporting expenses: {e}")

======================================================================

FILE: inventory-manager/src/tabs/statistics_tab.py
--------------------------------------------------
import streamlit as st
import pandas as pd
import plotly.express as px

class StatisticsTab:
    def __init__(self):
        pass
    
    def render(self):
        st.header("📊 Statistics")
        
        try:
            # Get database statistics
            stats = st.session_state.db_manager.get_database_stats()
            
            # Display basic stats
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Total Records", stats['records_count'])
            with col2:
                st.metric("Latest Record", stats['latest_record'][:16] if stats['latest_record'] != "None" else "None")
            
            if stats['records_count'] > 0:
                # Use half width for the chart
                col1, col2 = st.columns([1, 1])
                with col1:
                    self._render_genre_chart()
            else:
                st.info("No records available for analytics. Add some records first!")
                
        except Exception as e:
            st.error(f"Error loading statistics: {e}")

    def _render_genre_chart(self):
        """Render only the top 10 genre bar graph using assigned genres"""
        try:
            # Get genre statistics from records
            conn = st.session_state.db_manager._get_connection()
            
            # Count records by genre
            df = pd.read_sql('''
                SELECT 
                    genre,
                    COUNT(*) as record_count
                FROM records 
                WHERE genre IS NOT NULL AND genre != ''
                GROUP BY genre
                ORDER BY record_count DESC
                LIMIT 10
            ''', conn)
            conn.close()
            
            if len(df) > 0:
                fig = px.bar(
                    df,
                    x='record_count',
                    y='genre',
                    orientation='h',
                    title='Top 10 Genres',
                    color='record_count',
                    color_continuous_scale='blues'
                )
                fig.update_layout(
                    xaxis_title='Number of Records',
                    yaxis_title='Genre',
                    height=400,
                    showlegend=False
                )
                st.plotly_chart(fig, use_container_width=True)
            else:
                st.info("No genre data available for chart.")
                
        except Exception as e:
            st.error(f"Error rendering genre chart: {e}")

======================================================================

FILE: inventory-manager/src/tabs/check_in_tab.py
--------------------------------------------------
import streamlit as st
import pandas as pd
from datetime import datetime
import re
import time
from handlers.discogs_handler import DiscogsHandler
from handlers.ebay_handler import EbayHandler
from handlers.price_handler import PriceHandler

class CheckInTab:
    def __init__(self, discogs_handler, debug_tab, ebay_handler=None, price_handler=None):
        self.discogs_handler = discogs_handler
        self.ebay_handler = ebay_handler
        self.price_handler = price_handler
        self.debug_tab = debug_tab

    def render(self):
        """Render the check in functionality"""
        st.subheader("Check In Records")
        
        # Get formats from database
        formats = self._get_formats()
        format_options = [f['format_name'] for f in formats] if formats else ["Vinyl", "CDs", "Cassettes"]
        
        # Format and Condition selection
        col1, col2 = st.columns([1, 1])
        with col1:
            format_selected = st.selectbox(
                "Format",
                options=format_options,
                key="format_select"
            )
        with col2:
            condition = st.selectbox(
                "Condition",
                options=["1", "2", "3", "4", "5"],
                index=4,
                key="condition_select"
            )
        
        # Simple search form
        with st.form(key="search_form"):
            search_input = st.text_input(
                "Search",
                placeholder="Enter search term and press Enter or click Search",
                key="search_input"
            )
            
            col1, col2 = st.columns([1, 1])
            with col1:
                search_submitted = st.form_submit_button("Search", use_container_width=True)
            with col2:
                clear_submitted = st.form_submit_button("Clear Results", use_container_width=True)
        
        # Handle search
        if search_submitted and search_input and search_input.strip():
            self._perform_search(search_input.strip(), format_selected)
        
        # Handle clear
        if clear_submitted:
            st.session_state.current_search = ""
            st.rerun()
        
        # Show success message if record was just added
        if st.session_state.last_added:
            st.success(f"✅ Record added to database! (Barcode: {st.session_state.last_added})")
            # Increment update counter to refresh records tab
            st.session_state.records_updated += 1
            st.session_state.last_added = None
        
        # Display search results if available
        if st.session_state.current_search and st.session_state.current_search in st.session_state.search_results:
            self._render_search_results(st.session_state.current_search, st.session_state.search_results[st.session_state.current_search], format_selected, condition)

    def _get_formats(self):
        """Get available formats from database"""
        try:
            conn = st.session_state.db_manager._get_connection()
            df = pd.read_sql('SELECT * FROM formats ORDER BY format_name', conn)
            conn.close()
            return df.to_dict('records')
        except:
            return None

    def _perform_search(self, search_term, format_selected):
        """Perform the Discogs search"""
        with st.spinner(f"Searching Discogs for: {search_term}..."):
            try:
                search_results = self._search_discogs(search_term, format_selected)
                
                if search_results and search_results.get('results'):
                    st.session_state.current_search = search_term
                    st.session_state.search_results[search_term] = search_results
                else:
                    st.error(f"No results found for: {search_term}")
                    
            except Exception as e:
                st.error(f"Error searching Discogs: {str(e)}")

    def _search_discogs(self, search_term, format_selected):
        """Search Discogs and return multiple results"""
        try:
            search_query = f"{search_term} {format_selected}"
            filename_base = self._generate_filename(search_term, format_selected)
            
            search_data = self.discogs_handler.search_multiple_results(
                search_query, 
                filename_base
            )
            
            return search_data
            
        except Exception as e:
            return None

    def _get_discogs_url(self, result):
        """Convert Discogs API URI to proper Discogs website URL"""
        uri = result.get('uri') or result.get('resource_url')
        if not uri:
            return None
        
        if uri.startswith('/'):
            if '/releases/' in uri:
                release_id = uri.split('/releases/')[-1].split('-')[0]
                return f"https://www.discogs.com/release/{release_id}"
            elif '/masters/' in uri:
                master_id = uri.split('/masters/')[-1].split('-')[0]
                return f"https://www.discogs.com/master/{master_id}"
        
        release_id = result.get('id')
        if release_id:
            return f"https://www.discogs.com/release/{release_id}"
        
        return None

    def _render_search_results(self, search_term, search_data, format_selected, condition):
        """Render Discogs search results"""
        st.subheader(f"Results for: '{search_term}'")
        
        if not search_data or 'results' not in search_data or not search_data['results']:
            st.warning("No results found on Discogs")
            return
        
        results = search_data['results']
        st.write(f"Found **{len(results)}** results:")
        
        # Display results in a simple, performant way
        for i, result in enumerate(results):
            with st.container():
                col1, col2, col3, col4 = st.columns([1, 3, 2, 1])
                
                with col1:
                    image_url = self._extract_image_from_result(result)
                    if image_url:
                        st.image(image_url, width=80, use_container_width=False)
                
                with col2:
                    artist = self._extract_artist_from_result(result)
                    title = self._extract_title_from_result(result)
                    st.write(f"**{artist}**")
                    st.write(f"*{title}*")
                    
                    year = result.get('year', 'Unknown')
                    genre = ', '.join(result.get('genre', [])) or 'Unknown'
                    st.write(f"{year} • {genre}")
                    
                    catalog_number = self._extract_catalog_number(result)
                    if catalog_number:
                        st.write(f"Catalog: {catalog_number}")
                
                with col3:
                    # Show additional info
                    discogs_url = self._get_discogs_url(result)
                    if discogs_url:
                        st.markdown(f'[🔗 Discogs Page]({discogs_url})')
                
                with col4:
                    # Add button - this is the key functionality
                    if st.button("Add to DB", key=f"add_{i}_{hash(search_term)}", use_container_width=True):
                        success = self._add_result_to_database(result, search_term, format_selected, condition)
                        if success:
                            # Just show success message, don't clear search results
                            st.session_state.last_added = success
                            st.rerun()
                
                st.divider()

    def _add_result_to_database(self, result, search_term, format_selected, condition):
        """Add the selected result to the database"""
        try:
            release_id = result.get('id')
            if not release_id:
                st.error("No release ID found")
                return False
            
            filename_base = self._generate_filename(f"{search_term}_release_{release_id}", format_selected)
            
            # Get pricing information
            with st.spinner("Getting pricing data..."):
                pricing_data = self.discogs_handler.get_release_pricing(
                    str(release_id), 
                    search_term, 
                    filename_base
                )
            
            if not pricing_data or not pricing_data.get('success'):
                error_msg = pricing_data.get('error', 'Unable to get pricing data') if pricing_data else 'No pricing data returned'
                st.error(f"Failed to get pricing: {error_msg}")
                return False
            
            # Extract result information
            artist = self._extract_artist_from_result(result)
            title = self._extract_title_from_result(result)
            image_url = self._extract_image_from_result(result)
            raw_genre = ', '.join(result.get('genre', [])) or 'Unknown'
            year = result.get('year', '')
            catalog_number = self._extract_catalog_number(result)
            
            # Generate sequential barcode number
            next_barcode = self._generate_next_barcode()
            
            # Calculate file_at using assigned genre
            file_at_letter = self._calculate_file_at(artist)
            file_at = f"{raw_genre}({file_at_letter})"
            
            # Get eBay pricing if handler is available
            ebay_pricing = None
            if self.ebay_handler:
                with st.spinner("Getting eBay pricing..."):
                    try:
                        ebay_pricing = self.ebay_handler.get_ebay_pricing(artist, title)
                    except Exception as e:
                        pass
            
            # Calculate store price using PriceHandler
            store_price = self.price_handler.calculate_store_price(pricing_data['median_price'])
            
            # Save to database - using correct column names
            result_data = {
                'artist': artist,
                'title': title,
                'discogs_median_price': pricing_data['median_price'],
                'discogs_lowest_price': pricing_data.get('lowest_price'),
                'discogs_highest_price': pricing_data.get('highest_price'),
                'ebay_median_price': ebay_pricing.get('ebay_median_price') if ebay_pricing else None,
                'ebay_lowest_price': ebay_pricing.get('ebay_lowest_price') if ebay_pricing else None,
                'ebay_highest_price': ebay_pricing.get('ebay_highest_price') if ebay_pricing else None,
                'price': store_price,  # Store price for price tags
                'genre': raw_genre,
                'image_url': image_url,
                'format': format_selected,
                'catalog_number': catalog_number,
                'barcode': next_barcode,
                'condition': condition,
                'year': year,
                'discogs_have': 0,
                'discogs_want': 0,
                'file_at': file_at,
                'status': 'inventory'  # Default status
            }
            
            record_id = st.session_state.db_manager.save_record(result_data)
            return next_barcode  # Return barcode for success message
            
        except Exception as e:
            st.error(f"Error adding to database: {str(e)}")
            return False

    def _generate_next_barcode(self):
        """Generate next sequential barcode number"""
        try:
            conn = st.session_state.db_manager._get_connection()
            cursor = conn.cursor()
            cursor.execute('SELECT MAX(CAST(barcode AS INTEGER)) as max_barcode FROM records WHERE barcode GLOB "[0-9]*"')
            result = cursor.fetchone()
            conn.close()
            
            current_max = result[0] if result[0] is not None else 100000
            next_barcode = current_max + 1
            return str(next_barcode)
        except Exception as e:
            return str(int(time.time() * 1000))[-9:]

    def _extract_artist_from_result(self, result):
        """Extract artist name from Discogs result"""
        if result.get('artists') and isinstance(result['artists'], list):
            for artist in result['artists']:
                if artist.get('name'):
                    artist_name = artist['name']
                    artist_name = re.sub(r'\s*\(\d+\)\s*$', '', artist_name)
                    return artist_name.strip()
        
        if result.get('artist'):
            artist_name = result['artist']
            artist_name = re.sub(r'\s*\(\d+\)\s*$', '', artist_name)
            return artist_name.strip()
        
        if result.get('title'):
            title = result['title']
            if ' - ' in title:
                artist_name = title.split(' - ')[0].strip()
                artist_name = re.sub(r'\s*\(\d+\)\s*$', '', artist_name)
                return artist_name.strip()
        
        return 'Unknown Artist'

    def _extract_title_from_result(self, result):
        """Extract title from Discogs result"""
        if result.get('title'):
            title_text = result['title']
            if ' - ' in title_text:
                parts = title_text.split(' - ', 1)
                return parts[1].strip()
            return title_text
        return 'Unknown Title'

    def _extract_image_from_result(self, result):
        """Extract image URL from Discogs result"""
        image_fields = [
            result.get('cover_image'),
            result.get('thumb'),
            result.get('images', [{}])[0].get('uri'),
            result.get('images', [{}])[0].get('uri150'),
        ]
        
        for image_field in image_fields:
            if image_field and isinstance(image_field, str) and image_field.startswith('http'):
                return image_field
        
        return ""

    def _extract_catalog_number(self, result):
        """Extract catalog number from Discogs result - FIXED VERSION"""
        try:
            # Priority 1: Direct catno field
            if result.get('catno'):
                return result['catno']
            
            # Priority 2: Check labels array - FIXED: Handle both dict and string labels
            if result.get('label'):
                labels = result['label']
                if isinstance(labels, list):
                    for label in labels:
                        if isinstance(label, dict) and label.get('catno'):
                            return label['catno']
                        elif isinstance(label, str):
                            # If label is a string, it might contain catalog info
                            if any(char.isdigit() for char in label):
                                return label
                elif isinstance(labels, str):
                    # If label is a single string, check if it contains catalog info
                    if any(char.isdigit() for char in labels):
                        return labels
            
            # Priority 3: Check format array for catalog number
            if result.get('format') and isinstance(result['format'], list):
                for format_item in result['format']:
                    if isinstance(format_item, str) and any(char.isdigit() for char in format_item):
                        return format_item
            
            return ''
        except Exception as e:
            # If any error occurs, return empty string
            return ''

    def _generate_filename(self, search_query, format_name):
        """Generate a safe filename"""
        import re
        clean_query = re.sub(r'[^\w\s-]', '', search_query)
        clean_query = re.sub(r'[-\s]+', '_', clean_query)
        clean_format = re.sub(r'[^\w\s-]', '', format_name)
        clean_format = re.sub(r'[-\s]+', '_', clean_format)
        return f"batch_{clean_query}_{clean_format}".lower()

    def _calculate_file_at(self, artist):
        """Calculate file_at value for an artist"""
        if not artist:
            return "?"
        
        # Remove leading/trailing whitespace and convert to lowercase for processing
        artist_clean = artist.strip().lower()
        
        # Handle "The " prefix
        if artist_clean.startswith('the '):
            artist_clean = artist_clean[4:]
        
        # Handle numbers
        if artist_clean and artist_clean[0].isdigit():
            number_words = {
                '0': 'zero', '1': 'one', '2': 'two', '3': 'three', '4': 'four',
                '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine'
            }
            first_char = artist_clean[0]
            return number_words.get(first_char, '?')[0].upper()
        
        # Return first character if it's a letter
        if artist_clean and artist_clean[0].isalpha():
            return artist_clean[0].upper()
        
        return "?"

======================================================================

FILE: inventory-manager/src/tabs/import_export_tab.py
--------------------------------------------------
import streamlit as st
import pandas as pd
from datetime import datetime
import io
import os
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter

class ImportExportTab:
    def __init__(self):
        pass
    
    def render(self):
        st.header("🔄 Import/Export Records")
        
        col1, col2 = st.columns(2)
        
        with col1:
            self._render_export_section()
        
        with col2:
            self._render_import_section()
            
        st.divider()
        
        self._render_genre_printing_section()

    def _render_export_section(self):
        """Render the export functionality"""
        st.subheader("Export Records")
        
        # Column selection for export
        available_columns = [
            "id", "artist", "title", "discogs_median_price", "discogs_lowest_price", 
            "discogs_highest_price", "ebay_median_price", "ebay_lowest_price", 
            "ebay_highest_price", "genre", "image_url", "barcode", "format", 
            "condition", "year", "catalog_number", "file_at", "status"
        ]
        
        selected_columns = st.multiselect(
            "Select columns to export:",
            options=available_columns,
            default=["id", "artist", "title", "genre", "discogs_median_price", "barcode", "file_at"],
            help="Choose which columns to include in the export"
        )
        
        # Status filter for export
        export_status = st.selectbox(
            "Export records with status:",
            options=["inventory", "sold", "all"],
            help="Choose which records to export"
        )
        
        if st.button("📤 Export Custom CSV", use_container_width=True):
            if selected_columns:
                self._export_custom_csv(selected_columns, export_status)
            else:
                st.warning("Please select at least one column to export")

    def _render_import_section(self):
        """Render the import functionality"""
        st.subheader("Import Records")
        
        uploaded_file = st.file_uploader(
            "Upload CSV file with record updates",
            type=['csv'],
            help="Upload a CSV file with updated record data. Must include 'id' column."
        )
        
        if uploaded_file is not None:
            try:
                import_df = pd.read_csv(uploaded_file)
                
                if 'id' not in import_df.columns:
                    st.error("CSV must contain an 'id' column to identify records")
                else:
                    st.write(f"Found {len(import_df)} records in upload file")
                    st.write("Preview of uploaded data:")
                    st.dataframe(import_df.head())
                    
                    if st.button("🔄 Process Import", use_container_width=True):
                        updated_count = self._process_import_data(import_df)
                        if updated_count > 0:
                            st.success(f"✅ Successfully updated {updated_count} records!")
                            st.session_state.records_updated += 1
                            st.rerun()
                        else:
                            st.warning("No records were updated. Check if the data matches existing records.")
                
            except Exception as e:
                st.error(f"Error processing import file: {e}")

    def _render_genre_printing_section(self):
        """Render the genre signs printing functionality"""
        st.subheader("Genre Signs Printing")
        
        # Get unique genres from inventory
        try:
            conn = st.session_state.db_manager._get_connection()
            genres_df = pd.read_sql(
                "SELECT DISTINCT genre FROM records WHERE genre IS NOT NULL AND genre != '' AND status = 'inventory' ORDER BY genre",
                conn
            )
            conn.close()
            
            if len(genres_df) > 0:
                genre_options = genres_df['genre'].tolist()
            else:
                genre_options = ["ROCK", "JAZZ", "HIP-HOP", "ELECTRONIC", "POP", "METAL", "FOLK", "SOUL"]
                st.info("No genres found in inventory. Using default genre options.")
        except Exception as e:
            st.error(f"Error loading genres: {e}")
            genre_options = ["ROCK", "JAZZ", "HIP-HOP", "ELECTRONIC", "POP", "METAL", "FOLK", "SOUL"]
        
        col1, col2 = st.columns(2)
        with col1:
            print_option = st.radio(
                "Print option:",
                ["Single Genre", "All Genres"],
                key="print_option"
            )
            
            if print_option == "Single Genre":
                genre_text = st.selectbox("Select genre:", options=genre_options, key="genre_select")
            else:
                genre_text = "ALL_GENRES"
        
        with col2:
            font_size = st.slider("Font Size", min_value=24, max_value=96, value=48, key="genre_font_size")
        
        if st.button("🖨️ Generate Genre Sign PDF"):
            try:
                if print_option == "All Genres":
                    pdf_buffer = self._generate_all_genre_signs_pdf(genre_options, font_size)
                    filename = f"all_genre_signs_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
                else:
                    pdf_buffer = self._generate_genre_sign_pdf(genre_text, font_size)
                    filename = f"genre_sign_{genre_text.replace(' ', '_')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
                
                st.download_button(
                    label="⬇️ Download Genre Sign PDF",
                    data=pdf_buffer.getvalue(),
                    file_name=filename,
                    mime="application/pdf"
                )
            except Exception as e:
                st.error(f"Error generating genre sign: {e}")

    def _export_custom_csv(self, columns, status):
        """Export records with selected columns"""
        try:
            # Get records based on status
            conn = st.session_state.db_manager._get_connection()
            
            # Build query with selected columns
            columns_str = ', '.join(columns)
            
            if status == "all":
                query = f"SELECT {columns_str} FROM records"
            else:
                query = f"SELECT {columns_str} FROM records WHERE status = '{status}'"
            
            df = pd.read_sql_query(query, conn)
            conn.close()
            
            if len(df) > 0:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = f"custom_export_{status}_{timestamp}.csv"
                
                csv_data = df.to_csv(index=False)
                
                st.download_button(
                    label="⬇️ Download Custom CSV",
                    data=csv_data,
                    file_name=filename,
                    mime="text/csv",
                    key=f"download_custom_{timestamp}"
                )
                
                st.success(f"✅ Export ready! {len(df)} {status} records with selected columns.")
            else:
                st.warning(f"No {status} records to export.")
                
        except Exception as e:
            st.error(f"Error exporting custom CSV: {e}")

    def _process_import_data(self, import_df):
        """Process imported CSV data and update records"""
        try:
            updated_count = 0
            conn = st.session_state.db_manager._get_connection()
            cursor = conn.cursor()
            
            for _, row in import_df.iterrows():
                record_id = row.get('id')
                if not record_id:
                    continue
                
                # Build update query dynamically based on available columns
                update_fields = []
                update_values = []
                
                for column, value in row.items():
                    if column != 'id' and pd.notna(value):
                        update_fields.append(f"{column} = ?")
                        update_values.append(value)
                
                if update_fields:
                    update_values.append(record_id)  # For WHERE clause
                    query = f"UPDATE records SET {', '.join(update_fields)} WHERE id = ?"
                    cursor.execute(query, update_values)
                    updated_count += 1
            
            conn.commit()
            conn.close()
            return updated_count
            
        except Exception as e:
            st.error(f"Error processing import: {e}")
            return 0

    def _generate_genre_sign_pdf(self, genre, font_size):
        """Generate PDF with genre sign"""
        buffer = io.BytesIO()
        page_width, page_height = letter
        c = canvas.Canvas(buffer, pagesize=(page_width, page_height))
        
        text = genre.upper()
        font_name = "Helvetica-Bold"
        
        c.setFont(font_name, font_size)
        text_width = c.stringWidth(text, font_name, font_size)
        text_height = font_size
        
        x_center = page_width / 2
        y_center = page_height / 2
        
        border_padding = 12
        border_width = text_height + (2 * border_padding)
        border_height = text_width + (2 * border_padding)
        border_x = x_center - (border_width / 2)
        border_y = y_center - (border_height / 2)
        
        c.setStrokeColorRGB(0, 0, 0)
        c.setLineWidth(2)
        c.rect(border_x, border_y, border_width, border_height)
        
        c.saveState()
        c.translate(x_center, y_center)
        c.rotate(-90)
        c.setFont(font_name, font_size)
        c.drawString(-text_width/2, -text_height/2, text)
        c.restoreState()
        
        c.save()
        buffer.seek(0)
        return buffer

    def _generate_all_genre_signs_pdf(self, genres, font_size):
        """Generate PDF with all genre signs, one per page"""
        buffer = io.BytesIO()
        page_width, page_height = letter
        c = canvas.Canvas(buffer, pagesize=(page_width, page_height))
        font_name = "Helvetica-Bold"
        
        for i, genre in enumerate(genres):
            if i > 0:  # Start new page for each genre after the first one
                c.showPage()
            
            text = genre.upper()
            
            c.setFont(font_name, font_size)
            text_width = c.stringWidth(text, font_name, font_size)
            text_height = font_size
            
            x_center = page_width / 2
            y_center = page_height / 2
            
            border_padding = 12
            border_width = text_height + (2 * border_padding)
            border_height = text_width + (2 * border_padding)
            border_x = x_center - (border_width / 2)
            border_y = y_center - (border_height / 2)
            
            c.setStrokeColorRGB(0, 0, 0)
            c.setLineWidth(2)
            c.rect(border_x, border_y, border_width, border_height)
            
            c.saveState()
            c.translate(x_center, y_center)
            c.rotate(-90)
            c.setFont(font_name, font_size)
            c.drawString(-text_width/2, -text_height/2, text)
            c.restoreState()
        
        c.save()
        buffer.seek(0)
        return buffer

======================================================================

FILE: inventory-manager/src/handlers/discogs_handler.py
--------------------------------------------------
import requests
import json
import re
import time
from pathlib import Path
from typing import Dict, List, Optional

class DiscogsHandler:
    def __init__(self, user_token: str, debug_tab=None):
        self.user_token = user_token
        self.base_url = "https://api.discogs.com"
        self.headers = {
            "User-Agent": "PigStyleInventory/1.0",
            "Authorization": f"Discogs token={self.user_token}"
        }
        self.debug_tab = debug_tab
    
    def _log_debug(self, category, message, data=None):
        """Log to debug tab if available"""
        if self.debug_tab:
            self.debug_tab.add_log(category, message, data)
    
    def search_multiple_results(self, query: str, filename_base: str = None):
        """Search Discogs and return multiple results for user selection"""
        # Search for listings (items for sale)
        params = {
            'q': query,
            'type': 'release',
            'per_page': 50,  # Get more results for selection
            'currency': 'USD'
        }
        
        endpoint_url = f"{self.base_url}/database/search"
        
        self._log_debug("DISCOGS_REQUEST", f"Search request: {query}", {
            'endpoint': endpoint_url,
            'params': params,
            'headers': {k: '***' if 'Authorization' in k else v for k, v in self.headers.items()}
        })
        
        response = requests.get(
            endpoint_url,
            params=params,
            headers=self.headers,
            timeout=15
        )
        
        if response.status_code != 200:
            error_msg = f"Discogs API returned status {response.status_code}: {response.text}"
            self._log_debug("DISCOGS_ERROR", error_msg)
            raise Exception(error_msg)
        
        data = response.json()
        
        self._log_debug("DISCOGS_RESPONSE", f"Search completed: {len(data.get('results', []))} results", {
            'endpoint': endpoint_url,
            'result_count': len(data.get('results', [])),
            'response_sample': data.get('results', [])[:2] if data.get('results') else []
        })
        
        return data
    
    def get_release_pricing(self, release_id: str, query: str, filename_base: str = None):
        """Get pricing information for a specific release"""
        # First get release details
        release_data = self._get_release_stats(release_id)
        if not release_data:
            self._log_debug("DISCOGS_ERROR", f"No release data found for {release_id}")
            return self._create_no_results_response(0, query)
        
        # Then get marketplace listings for this specific release
        params = {
            'release_id': release_id,
            'per_page': 100,
            'currency': 'USD'
        }
        
        endpoint_url = f"{self.base_url}/marketplace/listings"
        
        self._log_debug("DISCOGS_REQUEST", f"Marketplace pricing request for release {release_id}", {
            'endpoint': endpoint_url,
            'params': params,
            'headers': {k: '***' if 'Authorization' in k else v for k, v in self.headers.items()}
        })

        response = requests.get(
            endpoint_url,
            params=params,
            headers=self.headers,
            timeout=15
        )
        
        if response.status_code != 200:
            # Fallback to using release stats if marketplace search fails
            self._log_debug("DISCOGS_WARNING", f"Marketplace search failed, using release stats for {release_id}")
            price = self._extract_price_from_release(release_data)
            image_url = self._extract_image_from_release(release_data)
            
            if price is not None:
                result = self._calculate_pricing_stats([price], 1, 1, query, 'release_stats')
                result['image_url'] = image_url
                result['release_data'] = release_data
                self._log_debug("DISCOGS_SUCCESS", f"Pricing from release stats: ${price}")
                return result
            else:
                result = self._create_no_results_response(1, query)
                result['image_url'] = image_url
                result['release_data'] = release_data
                self._log_debug("DISCOGS_WARNING", "No pricing data found in release stats")
                return result
        
        listings_data = response.json()
        
        self._log_debug("DISCOGS_RESPONSE", f"Marketplace listings retrieved: {len(listings_data.get('listings', []))} listings", {
            'endpoint': endpoint_url,
            'listings_count': len(listings_data.get('listings', [])),
            'pricing_sample': [listing.get('price', {}) for listing in listings_data.get('listings', [])[:3]] if listings_data.get('listings') else []
        })
        
        # Extract prices from listings
        prices = []
        for listing in listings_data.get('listings', []):
            price_str = listing.get('price', {}).get('value')
            if price_str:
                price = self._parse_price(price_str)
                if price is not None:
                    prices.append(price)
        
        image_url = self._extract_image_from_release(release_data)
        
        if prices:
            result = self._calculate_pricing_stats(prices, len(prices), len(listings_data.get('listings', [])), query, 'marketplace')
            result['image_url'] = image_url
            result['release_data'] = release_data
            self._log_debug("DISCOGS_SUCCESS", f"Pricing calculated: ${result['median_price']} median from {len(prices)} prices")
            return result
        else:
            # Fallback to release stats
            price = self._extract_price_from_release(release_data)
            if price is not None:
                result = self._calculate_pricing_stats([price], 1, 1, query, 'release_stats')
                result['image_url'] = image_url
                result['release_data'] = release_data
                self._log_debug("DISCOGS_SUCCESS", f"Pricing from release stats (fallback): ${price}")
                return result
            else:
                result = self._create_no_results_response(len(listings_data.get('listings', [])), query)
                result['image_url'] = image_url
                result['release_data'] = release_data
                self._log_debug("DISCOGS_WARNING", "No pricing data found")
                return result

    def _get_release_stats(self, release_id: str):
        """Get release statistics from Discogs API"""
        endpoint_url = f"{self.base_url}/releases/{release_id}"
        
        self._log_debug("DISCOGS_REQUEST", f"Getting release stats for {release_id}", {
            'endpoint': endpoint_url,
            'headers': {k: '***' if 'Authorization' in k else v for k, v in self.headers.items()}
        })
        
        response = requests.get(
            endpoint_url,
            headers=self.headers,
            timeout=10
        )
        
        if response.status_code == 200:
            data = response.json()
            self._log_debug("DISCOGS_RESPONSE", f"Release stats retrieved for {release_id}", {
                'endpoint': endpoint_url,
                'release_data_keys': list(data.keys()) if data else []
            })
            return data
        else:
            error_msg = f"Failed to get release {release_id}: {response.status_code}"
            self._log_debug("DISCOGS_ERROR", error_msg)
            raise Exception(error_msg)
    
    def _extract_price_from_release(self, release_data):
        """Extract price from release data"""
        price_fields = [
            release_data.get('lowest_price'),
            release_data.get('estimated_price'),
        ]
        
        for price_str in price_fields:
            if price_str:
                price = self._parse_price(price_str)
                if price is not None:
                    return price
        
        return None
    
    def _extract_image_from_release(self, release_data):
        """Extract image URL from release data"""
        # Try different possible image fields
        image_fields = [
            release_data.get('images', [{}])[0].get('uri'),
            release_data.get('images', [{}])[0].get('uri150'),
            release_data.get('thumb'),
            release_data.get('cover_image')
        ]
        
        for image_field in image_fields:
            if image_field and isinstance(image_field, str) and image_field.startswith('http'):
                return image_field
        
        return ""
    
    def _calculate_pricing_stats(self, prices, listings_with_prices: int, total_results: int, query: str, search_type: str):
        """Calculate pricing statistics from price list"""
        sorted_prices = sorted(prices)
        n = len(sorted_prices)
        
        # Calculate median
        if n % 2 == 1:
            median = sorted_prices[n//2]
        else:
            median = (sorted_prices[n//2 - 1] + sorted_prices[n//2]) / 2
        
        return {
            'median_price': round(median, 2),
            'lowest_price': min(prices),
            'highest_price': max(prices),
            'url': self._generate_marketplace_url(query),
            'currency': 'USD',
            'listings_with_prices': listings_with_prices,
            'prices_found': len(prices),
            'search_type': search_type,
            'success': True
        }
    
    def _create_no_results_response(self, total_results: int, query: str):
        """Create response when no pricing data is found"""
        return {
            'median_price': None,
            'lowest_price': None,
            'highest_price': None,
            'url': self._generate_marketplace_url(query),
            'listings_with_prices': 0,
            'prices_found': 0,
            'search_type': 'no_prices',
            'success': False,
            'error': 'No pricing data found'
        }
    
    def _parse_price(self, price_str):
        """Parse price string to float"""
        try:
            if not price_str:
                return None
            
            cleaned = re.sub(r'[^\d.,]', '', str(price_str))
            
            if not cleaned:
                return None
            
            if ',' in cleaned and '.' in cleaned:
                cleaned = cleaned.replace(',', '')
            elif ',' in cleaned:
                parts = cleaned.split(',')
                if len(parts) == 2 and len(parts[1]) <= 2:
                    cleaned = cleaned.replace(',', '.')
                else:
                    cleaned = cleaned.replace(',', '')
            
            cleaned = re.sub(r'[^\d.]', '', cleaned)
            
            if cleaned:
                price_float = float(cleaned)
                if 0.1 <= price_float <= 10000:
                    return round(price_float, 2)
            return None
        except (ValueError, TypeError):
            return None
    
    def _generate_marketplace_url(self, query: str):
        """Generate Discogs marketplace URL for the query"""
        encoded_query = requests.utils.quote(query)
        return f"https://www.discogs.com/sell/list?q={encoded_query}&currency=USD"
    
    def _save_payload(self, filename, data):
        """Save payload data to JSON file"""
        payloads_folder = Path("payloads")
        payloads_folder.mkdir(parents=True, exist_ok=True)
        file_path = payloads_folder / filename
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
        except Exception as e:
            pass

======================================================================

FILE: inventory-manager/src/handlers/__init__.py
--------------------------------------------------


======================================================================

FILE: inventory-manager/src/handlers/draft_csv_handler.py
--------------------------------------------------
import csv
import io
from pathlib import Path

class DraftCSVHandler:
    INFO_LINE = "#INFO,Version=0.0.2,Template= eBay-draft-listings-template_US,,,,,,,,"
    HEADERS = [
        "Action(SiteID=US|Country=US|Currency=USD|Version=1193|CC=UTF-8)",
        "Custom label (SKU)",
        "Category ID",
        "Title",
        "UPC",
        "Price",
        "Quantity",
        "Item photo URL",
        "Condition ID",
        "Description",
        "C:Artist",   
    ]

    REQUIRED_FIELDS = [
        "Title",
        "Price",
        "Item photo URL",
        "Condition ID",
        "Description",
    ]

    def __init__(self, file_path="ebay_drafts.csv"):
        self.file_path = Path(file_path)
        self.rows = []
        self.load_existing()

    def load_existing(self):
        if self.file_path.exists():
            with open(self.file_path, newline='', encoding="utf-8") as f:
                reader = csv.DictReader(f)
                for row in reader:
                    clean_row = {h: (row.get(h, "") or "").strip() for h in self.HEADERS}
                    if self._is_valid(clean_row):
                        self.rows.append(clean_row)

    def _is_valid(self, row: dict) -> bool:
        missing = [field for field in self.REQUIRED_FIELDS if not str(row.get(field, "")).strip()]
        if missing:
            return False
        return True

    def add_row(self, data: dict):
        clean_row = {h: str(data.get(h, "")).strip() for h in self.HEADERS}
        if not self._is_valid(clean_row):
            return False
        self.rows.append(clean_row)
        return True

    def save_csv(self, file_obj=None):
        """
        Save CSV. If file_obj is provided (like io.StringIO), write to it.
        Otherwise, write to self.file_path.
        """
        valid_rows = [row for row in self.rows if self._is_valid(row)]
        if file_obj:
            writer = csv.DictWriter(file_obj, fieldnames=self.HEADERS)
            file_obj.write(self.INFO_LINE + "\n")
            writer.writeheader()
            writer.writerows(valid_rows)
        else:
            with open(self.file_path, "w", newline="", encoding="utf-8") as f:
                f.write(self.INFO_LINE + "\n")
                writer = csv.DictWriter(f, fieldnames=self.HEADERS)
                writer.writeheader()
                writer.writerows(valid_rows)

    def generate_ebay_txt_from_records(self, records, price_handler=None):
        """Generate eBay formatted TXT content from record data"""
        output = io.StringIO()
        
        # Write info line
        output.write(self.INFO_LINE + "\n")
        
        # Write headers
        output.write(",".join(self.HEADERS) + "\n")
        
        # Write data rows
        for record in records:
            row_data = self._format_record_for_ebay(record, price_handler)
            if row_data:
                row_values = [str(row_data.get(header, "")) for header in self.HEADERS]
                output.write(",".join(row_values) + "\n")
        
        return output.getvalue()

    def _format_record_for_ebay(self, record, price_handler=None):
        """Format a single record for eBay import - use calculated eBay price"""
        # Map format to eBay category ID
        category_map = {
            "Vinyl": "176985",
            "CDs": "176984", 
            "Cassettes": "176983"
        }
        
        # Map condition to eBay condition ID
        condition_map = {
            "1": "3000",
            "2": "3000",  
            "3": "3000",
            "4": "3000",
            "5": "1000",
        }
        
        # Get basic fields
        artist = record.get('artist', 'Unknown Artist')
        title = record.get('title', 'Unknown Title')
        format_type = record.get('format', 'Vinyl')
        condition = record.get('condition', '4')
        barcode = record.get('barcode', '')
        image_url = record.get('image_url', '')
        
        # Calculate eBay price using PriceHandler
        if price_handler:
            ebay_price = price_handler.calculate_ebay_price(record.get('ebay_lowest_price'))
        else:
            # Fallback: use discogs median price if no price handler
            ebay_price = record.get('discogs_median_price', 0) or 0
        
        # Simple SKU from barcode or title
        if barcode:
            sku = f"VINYL_{barcode}"
        else:
            sku = f"{title.replace(' ', '')}-{format_type.upper()}"
        sku = sku[:30]
        
        # Simple description
        description = f"{artist} - {title}"
        
        # Title includes artist
        ebay_title = f"{artist} - {title}"
        
        return {
            "Action(SiteID=US|Country=US|Currency=USD|Version=1193|CC=UTF-8)": "Draft",
            "Custom label (SKU)": sku,
            "Category ID": category_map.get(format_type, "176985"),
            "Title": ebay_title,
            "UPC": barcode,
            "Price": f"{float(ebay_price):.2f}",
            "Quantity": "1",
            "Item photo URL": image_url,
            "Condition ID": condition_map.get(condition, "3000"),
            "Description": description,
            "C:Artist": artist,
        }

======================================================================

FILE: inventory-manager/src/handlers/price_handler.py
--------------------------------------------------
class PriceHandler:
    def __init__(self, ebay_cutoff_price=3.99):
        self.ebay_cutoff_price = ebay_cutoff_price
    
    def set_ebay_cutoff_price(self, cutoff_price):
        """Set the eBay cutoff price"""
        self.ebay_cutoff_price = cutoff_price
    
    def calculate_store_price(self, discogs_median_price):
        """
        Calculate store price from Discogs median price.
        Rounds up to .99 (3.56 becomes 3.99, 54 becomes 53.99)
        """
        if not discogs_median_price or discogs_median_price <= 0:
            return 0.0
        
        # Round up to nearest whole number then subtract 0.01 to get .99
        import math
        rounded_up = math.ceil(discogs_median_price)
        store_price = rounded_up - 0.01
        
        return round(store_price, 2)
    
    def calculate_ebay_price(self, ebay_lowest_price):
        """
        Calculate eBay price from eBay lowest price.
        Rounds down to .49 or .99 with cutoff at self.ebay_cutoff_price
        """
        if not ebay_lowest_price or ebay_lowest_price <= 0:
            return 0.0
        
        # Apply cutoff - don't go below the cutoff price
        if ebay_lowest_price < self.ebay_cutoff_price:
            ebay_price = self.ebay_cutoff_price
        else:
            ebay_price = ebay_lowest_price
        
        # Round down to nearest .49 or .99
        import math
        base_price = math.floor(ebay_price)
        
        # If the decimal part is >= 0.50, use .99, otherwise use .49
        decimal_part = ebay_price - base_price
        if decimal_part >= 0.50:
            ebay_price = base_price + 0.99
        else:
            ebay_price = base_price + 0.49
        
        return round(ebay_price, 2)
    
    def calculate_prices_for_record(self, record):
        """
        Calculate both store and eBay prices for a record
        Returns: (store_price, ebay_price)
        """
        discogs_median = record.get('discogs_median_price') or 0
        ebay_lowest = record.get('ebay_lowest_price') or 0
        
        store_price = self.calculate_store_price(discogs_median)
        ebay_price = self.calculate_ebay_price(ebay_lowest)
        
        return store_price, ebay_price

======================================================================

FILE: inventory-manager/src/handlers/genre_handler.py
--------------------------------------------------
import streamlit as st
import pandas as pd
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
import io

class GenreHandler:
    def get_unique_genres(self):
        """Get unique genres from inventory"""
        try:
            conn = st.session_state.db_manager._get_connection()
            genres_df = pd.read_sql(
                "SELECT DISTINCT genre FROM records WHERE genre IS NOT NULL AND genre != '' AND status = 'inventory' ORDER BY genre",
                conn
            )
            conn.close()
            
            if len(genres_df) > 0:
                return genres_df['genre'].tolist()
            else:
                return ["ROCK", "JAZZ", "HIP-HOP", "ELECTRONIC", "POP", "METAL", "FOLK", "SOUL"]
        except Exception as e:
            return ["ROCK", "JAZZ", "HIP-HOP", "ELECTRONIC", "POP", "METAL", "FOLK", "SOUL"]
    
    def generate_genre_sign_pdf(self, genre, font_size):
        """Generate PDF with genre sign"""
        buffer = io.BytesIO()
        page_width, page_height = letter
        c = canvas.Canvas(buffer, pagesize=(page_width, page_height))
        
        text = genre.upper()
        font_name = "Helvetica-Bold"
        
        c.setFont(font_name, font_size)
        text_width = c.stringWidth(text, font_name, font_size)
        text_height = font_size
        
        x_center = page_width / 2
        y_center = page_height / 2
        
        border_padding = 12
        border_width = text_height + (2 * border_padding)
        border_height = text_width + (2 * border_padding)
        border_x = x_center - (border_width / 2)
        border_y = y_center - (border_height / 2)
        
        c.setStrokeColorRGB(0, 0, 0)
        c.setLineWidth(2)
        c.rect(border_x, border_y, border_width, border_height)
        
        c.saveState()
        c.translate(x_center, y_center)
        c.rotate(-90)
        c.setFont(font_name, font_size)
        c.drawString(-text_width/2, -text_height/2, text)
        c.restoreState()
        
        c.save()
        buffer.seek(0)
        return buffer

    def generate_all_genre_signs_pdf(self, genres, font_size):
        """Generate PDF with all genre signs, one per page"""
        buffer = io.BytesIO()
        page_width, page_height = letter
        c = canvas.Canvas(buffer, pagesize=(page_width, page_height))
        font_name = "Helvetica-Bold"
        
        for i, genre in enumerate(genres):
            if i > 0:  # Start new page for each genre after the first one
                c.showPage()
            
            text = genre.upper()
            
            c.setFont(font_name, font_size)
            text_width = c.stringWidth(text, font_name, font_size)
            text_height = font_size
            
            x_center = page_width / 2
            y_center = page_height / 2
            
            border_padding = 12
            border_width = text_height + (2 * border_padding)
            border_height = text_width + (2 * border_padding)
            border_x = x_center - (border_width / 2)
            border_y = y_center - (border_height / 2)
            
            c.setStrokeColorRGB(0, 0, 0)
            c.setLineWidth(2)
            c.rect(border_x, border_y, border_width, border_height)
            
            c.saveState()
            c.translate(x_center, y_center)
            c.rotate(-90)
            c.setFont(font_name, font_size)
            c.drawString(-text_width/2, -text_height/2, text)
            c.restoreState()
        
        c.save()
        buffer.seek(0)
        return buffer

======================================================================

FILE: inventory-manager/src/handlers/ebay_handler.py
--------------------------------------------------
import requests
import time
import re
import json
from pathlib import Path

class EbayHandler:
    EBAY_TOKEN_URL = "https://api.ebay.com/identity/v1/oauth2/token"
    EBAY_SEARCH_URL = "https://api.ebay.com/buy/browse/v1/item_summary/search"

    def __init__(self, client_id, client_secret, debug_tab=None):
        self.client_id = client_id
        self.client_secret = client_secret
        self.debug_tab = debug_tab
        self.token = None
        self.token_expiry = 0

    def _log_debug(self, category, message, data=None):
        """Log to debug tab if available"""
        if self.debug_tab:
            self.debug_tab.add_log(category, message, data)

    def get_access_token(self):
        if self.token and time.time() < self.token_expiry:
            return self.token

        headers = {"Content-Type": "application/x-www-form-urlencoded"}
        data = {"grant_type": "client_credentials", "scope": "https://api.ebay.com/oauth/api_scope"}

        try:
            self._log_debug("EBAY_REQUEST", "Getting access token", {
                'endpoint': self.EBAY_TOKEN_URL,
                'headers': headers
            })
            
            resp = requests.post(self.EBAY_TOKEN_URL, headers=headers, data=data, auth=(self.client_id, self.client_secret))
            resp.raise_for_status()
            token_data = resp.json()
            self.token = token_data["access_token"]
            self.token_expiry = time.time() + token_data["expires_in"] - 60
            
            self._log_debug("EBAY_RESPONSE", "Access token obtained successfully", {
                'endpoint': self.EBAY_TOKEN_URL,
                'token_expires_in': token_data["expires_in"]
            })
            
            return self.token
        except Exception as e:
            self._log_debug("EBAY_ERROR", f"Failed to get access token: {e}")
            return None

    def get_ebay_pricing(self, artist, title, category_id="176985", exclude_foreign=True):
        """Get eBay pricing for a record"""
        if not self.get_access_token():
            self._log_debug("EBAY_ERROR", "No access token available")
            return None

        headers = {"Authorization": f"Bearer {self.token}"}
        query = f"{artist} {title}".strip()
        params = {
            "q": query, 
            "limit": 50, 
            "category_ids": category_id,
            "filter": "conditions:USED|NEW"
        }

        try:
            self._log_debug("EBAY_REQUEST", f"Searching eBay for: {query}", {
                'endpoint': self.EBAY_SEARCH_URL,
                'params': params,
                'headers': {k: '***' if 'Authorization' in k else v for k, v in headers.items()}
            })
            
            resp = requests.get(self.EBAY_SEARCH_URL, headers=headers, params=params, timeout=15)
            resp.raise_for_status()
            data = resp.json()

            items = data.get("itemSummaries", [])
            
            self._log_debug("EBAY_RESPONSE", f"eBay search completed: {len(items)} listings found", {
                'endpoint': self.EBAY_SEARCH_URL,
                'result_count': len(items),
                'pricing_sample': [{
                    'title': item.get('title', '')[:50] + '...' if len(item.get('title', '')) > 50 else item.get('title', ''),
                    'price': item.get('price', {}).get('value'),
                    'condition': item.get('condition', 'Unknown')
                } for item in items[:3]] if items else []
            })

            prices = []
            for item in items:
                try:
                    # Filter out foreign listings if requested
                    if exclude_foreign:
                        marketplace_id = item.get("listingMarketplaceId")
                        if marketplace_id and marketplace_id != "EBAY_US":
                            continue

                    price_data = item.get("price", {})
                    if "value" in price_data:
                        price = float(price_data["value"])
                        prices.append(price)
                except Exception as e:
                    continue

            if prices:
                sorted_prices = sorted(prices)
                n = len(sorted_prices)
                
                # Calculate median
                if n % 2 == 1:
                    median = sorted_prices[n//2]
                else:
                    median = (sorted_prices[n//2 - 1] + sorted_prices[n//2]) / 2

                result = {
                    'ebay_median_price': round(median, 2),
                    'ebay_lowest_price': min(prices),
                    'ebay_highest_price': max(prices),
                    'ebay_listings_count': len(prices)
                }
                
                self._log_debug("EBAY_SUCCESS", f"eBay pricing calculated: ${result['ebay_median_price']} median from {len(prices)} prices", {
                    'median_price': result['ebay_median_price'],
                    'price_range': f"${result['ebay_lowest_price']} - ${result['ebay_highest_price']}",
                    'listings_count': len(prices)
                })
                
                return result
            else:
                self._log_debug("EBAY_WARNING", "No eBay pricing data found for the search")
                return None

        except Exception as e:
            self._log_debug("EBAY_ERROR", f"eBay API error: {e}")
            return None

======================================================================

FILE: inventory-manager/src/handlers/imagebb_handler.py
--------------------------------------------------
import requests

class ImageBBHandler:
    """
    Handles uploading local images to ImageBB.
    Returns a publicly accessible direct image URL.
    Requires an API key from https://api.imgbb.com/.
    """

    API_UPLOAD_URL = "https://api.imgbb.com/1/upload"

    def __init__(self, api_key: str):
        self.api_key = api_key

    def upload_from_file(self, file_path: str) -> str:
        """
        Upload a local image file to ImageBB and return the direct URL.
        """
        with open(file_path, "rb") as f:
            payload = {
                "key": self.api_key,
            }
            files = {
                "image": f
            }
            response = requests.post(self.API_UPLOAD_URL, data=payload, files=files)

        if response.status_code == 200:
            data = response.json()
            if data.get("success"):
                # The 'url' field is a direct link to the image
                return data["data"]["url"]
            else:
                raise Exception(f"ImageBB upload failed: {data}")
        else:
            raise Exception(f"HTTP error {response.status_code}: {response.text}")


# Example usage:
if __name__ == "__main__":
    API_KEY = "YOUR_IMGBB_API_KEY"
    handler = ImageBBHandler(API_KEY)
    direct_url = handler.upload_from_file("SportyThievz.jpg")
    print("Uploaded image URL:", direct_url)


======================================================================

FILE: inventory-manager/src/handlers/barcode_generator.py
--------------------------------------------------
import streamlit as st
import barcode
from barcode.writer import ImageWriter
import io
import os

class BarcodeGenerator:
    """Generates scannable barcodes for inventory items"""
    
    def __init__(self):
        self.barcode_dir = "barcodes"
        os.makedirs(self.barcode_dir, exist_ok=True)
    
    def generate_barcode_image(self, barcode_number, barcode_type='code128'):
        """Generate a barcode image for the given number"""
        try:
            # Validate barcode number is numeric
            if not barcode_number.isdigit():
                raise ValueError("Barcode must contain only digits")
            
            # Create barcode
            if barcode_type == 'code128':
                barcode_class = barcode.get_barcode_class('code128')
            elif barcode_type == 'code39':
                barcode_class = barcode.get_barcode_class('code39')
            else:
                barcode_class = barcode.get_barcode_class('code128')
            
            # Generate barcode
            barcode_obj = barcode_class(barcode_number, writer=ImageWriter())
            
            # Save to bytes buffer
            buffer = io.BytesIO()
            barcode_obj.write(buffer)
            buffer.seek(0)
            
            return buffer
            
        except Exception as e:
            st.error(f"Error generating barcode: {e}")
            return None
    
    def save_barcode_image(self, barcode_number, filename=None):
        """Save barcode image to file"""
        try:
            if filename is None:
                filename = f"barcode_{barcode_number}.png"
            
            filepath = os.path.join(self.barcode_dir, filename)
            buffer = self.generate_barcode_image(barcode_number)
            
            if buffer:
                with open(filepath, 'wb') as f:
                    f.write(buffer.getvalue())
                return filepath
            return None
            
        except Exception as e:
            st.error(f"Error saving barcode: {e}")
            return None
    
    def display_barcode(self, barcode_number, width=200):
        """Display barcode in Streamlit"""
        try:
            buffer = self.generate_barcode_image(barcode_number)
            if buffer:
                st.image(buffer, width=width, caption=f"Barcode: {barcode_number}")
                return buffer
            return None
        except Exception as e:
            st.error(f"Error displaying barcode: {e}")
            return None

======================================================================

