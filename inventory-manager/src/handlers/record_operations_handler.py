import streamlit as st
import pandas as pd
from datetime import datetime
import time
import re

class RecordOperationsHandler:
    def __init__(self, discogs_handler=None, ebay_handler=None, gallery_json_manager=None):
        self.discogs_handler = discogs_handler
        self.ebay_handler = ebay_handler
        self.gallery_json_manager = gallery_json_manager

    def add_inventory_record(self, record_data, condition, genre, search_term):
        """Add inventory record to database with both Discogs and eBay data - NO custom price calculations"""
        try:
            release_id = record_data.get('discogs_id')
            
            if not release_id:
                st.error("No release ID found")
                return False, None
            
            # Get format from session state or default
            format_selected = st.session_state.get('format_select', 'Vinyl')
            
            # Get Discogs pricing information
            if self.discogs_handler:
                # Note: The actual API call logging is now handled within discogs_handler
                pricing_data = self.discogs_handler.get_release_pricing(
                    str(release_id), 
                    search_term, 
                    f"release_{release_id}"
                )
            else:
                st.error("Discogs handler not available")
                return False, None
            
            if not pricing_data or not pricing_data.get('success'):
                error_msg = pricing_data.get('error', 'Unable to get pricing data') if pricing_data else 'No pricing data returned'
                st.error(f"Failed to get Discogs pricing: {error_msg}")
                return False, None
            
            # Extract result information - use the edited artist name if available
            artist = record_data.get('artist', '')  # This will be the edited version
            title = record_data.get('title', '')    # This will be the edited version
            image_url = record_data.get('image_url', '')
            catalog_number = record_data.get('catalog_number', '')
            discogs_genre = record_data.get('genre', '')  # Store the original Discogs genre
            youtube_url = record_data.get('youtube_url', '')  # Get YouTube URL from record data
            
            # Get eBay pricing if handler is available - use the edited artist name
            ebay_pricing = None
            if self.ebay_handler and artist and title:
                # Note: The actual API call logging is now handled within ebay_handler
                try:
                    ebay_pricing = self.ebay_handler.get_ebay_pricing(artist, title)
                except Exception as e:
                    st.warning(f"Could not fetch eBay pricing: {e}")
                    ebay_pricing = None
            
            # Get genre_id for the genre
            genre_id = None
            if genre:
                conn = st.session_state.db_manager._get_connection()
                cursor = conn.cursor()
                cursor.execute('SELECT id FROM genres WHERE genre_name = ?', (genre,))
                genre_result = cursor.fetchone()
                if genre_result:
                    genre_id = genre_result[0]
                else:
                    # Create new genre
                    cursor.execute('INSERT INTO genres (genre_name) VALUES (?)', (genre,))
                    genre_id = cursor.lastrowid
                    conn.commit()
                conn.close()
            
            # Save to database - include raw Discogs and eBay data only
            # NO custom price calculations (ebay_sell_at and store_price will be NULL initially)
            result_data = {
                'artist': artist,  # Use the edited artist name
                'title': title,    # Use the edited title
                'barcode': '',  # Will be generated by trigger
                'genre_id': genre_id,
                'image_url': image_url,
                'discogs_median_price': pricing_data['median_price'],
                'discogs_lowest_price': pricing_data.get('lowest_price'),
                'discogs_highest_price': pricing_data.get('highest_price'),
                # eBay data - use actual values if available, otherwise NULL
                'ebay_median_price': ebay_pricing.get('ebay_median_price') if ebay_pricing else None,
                'ebay_lowest_price': ebay_pricing.get('ebay_lowest_price') if ebay_pricing else None,
                'ebay_highest_price': ebay_pricing.get('ebay_highest_price') if ebay_pricing else None,
                'ebay_count': ebay_pricing.get('ebay_listings_count') if ebay_pricing else None,
                'ebay_low_shipping': ebay_pricing.get('ebay_low_shipping') if ebay_pricing else None,
                'ebay_low_url': ebay_pricing.get('ebay_search_url') if ebay_pricing else None,
                'catalog_number': catalog_number,
                'format': format_selected,
                'condition': condition,
                'file_at': '',  # Will be generated by trigger
                'store_price': None,
                'discogs_genre': discogs_genre,  # Store the original Discogs genre
                'youtube_url': youtube_url  # Include YouTube URL
            }
            
            record_id = st.session_state.db_manager.save_record(result_data)
            
            # Force update file_at after record is created
            if genre_id and artist:
                self._update_file_at(record_id, artist, genre_id)
            
            # Trigger JSON rebuild after successful addition
            if record_id and self.gallery_json_manager:
                self.gallery_json_manager.trigger_rebuild(async_mode=True)
            
            # Get the generated barcode for success message
            record = st.session_state.db_manager.get_record_by_barcode(str(record_id))
            barcode = record.get('barcode') if record else str(record_id)
            
            return True, record_id
            
        except Exception as e:
            st.error(f"Error adding to database: {str(e)}")
            return False, None

    def _update_file_at(self, record_id, artist, genre_id):
        """Manually update file_at column for the record"""
        try:
            conn = st.session_state.db_manager._get_connection()
            cursor = conn.cursor()
            
            # Get genre name
            cursor.execute('SELECT genre_name FROM genres WHERE id = ?', (genre_id,))
            genre_result = cursor.fetchone()
            genre = genre_result[0] if genre_result else 'Unknown'
            
            # Calculate file_at letter
            file_at_letter = self._calculate_file_at(artist)
            file_at_value = f"{genre}({file_at_letter})"
            
            # Update file_at
            cursor.execute('UPDATE records SET file_at = ? WHERE id = ?', (file_at_value, record_id))
            conn.commit()
            conn.close()
            
        except Exception as e:
            print(f"Error updating file_at: {e}")

    def _calculate_file_at(self, artist):
        """Calculate file_at value for an artist"""
        if not artist:
            return "?"
        
        artist_clean = artist.strip().lower()
        
        if artist_clean.startswith('the '):
            artist_clean = artist_clean[4:]
        
        if artist_clean and artist_clean[0].isdigit():
            number_words = {
                '0': 'zero', '1': 'one', '2': 'two', '3': 'three', '4': 'four',
                '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine'
            }
            first_char = artist_clean[0]
            return number_words.get(first_char, '?')[0].upper()
        
        if artist_clean and artist_clean[0].isalpha():
            return artist_clean[0].upper()
        
        return "?"

    def update_database_record(self, record_data, condition, genre):
        """Update database record"""
        try:
            record_id = record_data['id']
            
            # Get genre_id for the genre
            genre_id = None
            if genre:
                conn = st.session_state.db_manager._get_connection()
                cursor = conn.cursor()
                cursor.execute('SELECT id FROM genres WHERE genre_name = ?', (genre,))
                genre_result = cursor.fetchone()
                if genre_result:
                    genre_id = genre_result[0]
                conn.close()
            
            updates = {
                'condition': condition,
                'genre_id': genre_id
            }
            
            success = st.session_state.db_manager.update_record(record_id, updates)
            
            # Trigger JSON rebuild after successful update
            if success and self.gallery_json_manager:
                self.gallery_json_manager.trigger_rebuild(async_mode=True)
                
            return success
                
        except Exception as e:
            st.error(f"Error updating record: {str(e)}")
            return False

    def process_checkout(self, checkout_records):
        """Process checkout of selected records - not available anymore"""
        st.warning("Checkout functionality is not available. The status column has been removed from the database.")
        return 0

    def generate_receipt_content(self, checkout_records):
        """Generate receipt content for checkout records"""
        try:
            receipt_lines = []
            receipt_lines.append("PIGSTYLE RECORDS - CHECKOUT RECEIPT")
            receipt_lines.append("=" * 40)
            receipt_lines.append(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M')}")
            receipt_lines.append(f"Items: {len(checkout_records)}")
            receipt_lines.append("")
            
            total = 0
            for i, record in enumerate(checkout_records, 1):
                artist = record.get('artist', 'Unknown Artist')
                title = record.get('title', 'Unknown Title')
                price = record.get('store_price', 0) or 0
                total += price
                
                # Truncate long titles for receipt format
                if len(title) > 30:
                    title = title[:27] + "..."
                if len(artist) > 20:
                    artist = artist[:17] + "..."
                
                receipt_lines.append(f"{i:2d}. {artist:<20} {title:<30} ${price:>6.2f}")
            
            receipt_lines.append("")
            receipt_lines.append("=" * 40)
            receipt_lines.append(f"TOTAL: ${total:>33.2f}")
            receipt_lines.append("")
            receipt_lines.append("Thank you for your purchase!")
            
            return "\n".join(receipt_lines)
            
        except Exception as e:
            return f"Error generating receipt: {e}"